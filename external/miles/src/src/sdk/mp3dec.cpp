//############################################################################
//##                                                                        ##
//##  Miles Sound System                                                    ##
//##                                                                        ##
//##  MPDEC.CPP: ASI API module for MPEG audio                              ##
//##                                                                        ##
//##  16-bit protected-mode source compatible with MSC 7.0                  ##
//##  32-bit protected-mode source compatible with MSC 11.0/Watcom 10.6     ##
//##                                                                        ##
//##  Version 1.00 of 8-Apr-98: Initial                                     ##
//##                                                                        ##
//##  Author: John Miles                                                    ##
//##                                                                        ##
//############################################################################
//##                                                                        ##
//##  Copyright (C) RAD Game Tools, Inc.                                    ##
//##                                                                        ##
//##  Contact RAD Game Tools at 425-893-4300 for technical support.         ##
//##                                                                        ##
//############################################################################

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>

#include "mss.h"
#include "mp3decode.h"

// Set to force the math kernels to use a c implementation.
#if defined(IS_PSP) || defined(__RADSEKRIT2__) || defined(IS_PSP2) || defined(MSS_SPU_PROCESS) || defined(IS_IPHONE) || (defined(__POWERPC__) && defined(__MACH__)) || defined(IS_3DS) || defined(IS_WIIU) || defined(__RADANDROID__)
#define FORCE_SCALAR_MATH 1
#else
#define FORCE_SCALAR_MATH 0
#endif

#ifdef IS_PS2
#include <eeregs.h>
#endif

#if defined(IS_X86) && !defined(SSE_ONLY)
#define SSE_ONLY
#endif

#ifdef IS_PS2

#if 0

#define CLOCK_SPEED_MS  300000

#include <eekernel.h>
inline __int64 __rdtsc(int reset)
{
    int old;
    U32 now;
    __int64 ret;
    static volatile U32 prev;
    static volatile __int64 time;

    old = DI();

    asm __volatile__("mfc0 %0,$9" : "=r" (now) : );

    if (now < prev)
        time += 0xffffffff - prev + now + 1;
    else
        time += now - prev;

    prev = now;
    ret = time;

    if(old)
        EI();

    return ret;
}

#endif

#else

#if 0

// NOTE only correct for a specific P4
#define CLOCK_SPEED_MS  2785000

#pragma warning(disable:4035)
__int64 __rdtsc(int reset)
{
    __asm rdtsc
}

#endif

#endif

#ifdef __WATCOMC__
#pragma warning 7 9
#pragma warning 14 9
#endif

#ifdef __SNC__
#pragma diag_suppress=171 // pointer points outside of underlying object
#endif

#ifdef IS_WIN16
#pragma warning (disable:4136)
#endif

#define max(a,b)  (((a) > (b)) ? (a) : (b))
#define min(a,b)  (((a) < (b)) ? (a) : (b))

/* @cdep pre

  $if($equals($BuildPlatform,spu)$BuildingSPUProcess, ,$requires(Mp3api.cpp) )  // everything needs mp3api.cpp, except spu

  $if($equals($BuildPlatform,ps3),
    $path($clipfilename($file), *.s)
    $requires(math_gcc_ppc.s)
    $requires(math_c.cpp)

  ,
  $if($equals($BuildPlatform,xenon),
    $path($clipfilename($file), *.c;*.h;*.asm;*.cpp;*.noltcg)
    $requires(xenon_mp3.c.noltcg)
    $requires(math_c.cpp)
  ,
  $if($equals($BuildPlatform,ps2),
    $requires(math_s.s)
  ,
  $if($equals($BuildPlatform,wii),
    $requires(math_ppc.c)
  ,
  $if($equals($BuildPlatform,spu)$BuildingSPUProcess,
    $requires(math_c.cpp)
  ,
  $if($equals($BuildPlatform,win32)$equals($BuildPlatform,win64)$equals($BuildPlatform,durango),
    $requires(math_a.asm)
    $requires(math_sse.asm)
  ,
  $requires(math_c.cpp) // default to c implementation for everything.

  ))))))
*/

//
// Dewindows offset to correct for alignment, only used on platforms with
// vectorized dewindow
//
#if VECTOR_DEWINDOW
F32* s_DewindowOff4, *s_DewindowOff8, *s_DewindowOff12;
static F32* s_DewindowOff4raw, *s_DewindowOff8raw, *s_DewindowOff12raw;
static MSS_FREE_TYPE * l3free = 0;
#endif

// huffman tables (see makehuff)

static const U8 mp3_htbls[] =
{
  33, 80, 64, 80, 96, 80, 128, 128, 127, 128, 126, 81, 160, 129, 166,
  130, 173, 131, 174, 132, 201, 133, 217, 134, 224, 135, 173, 137, 172, 137,
  74, 139, 73, 139, 72, 139, 71, 139, 70, 139, 69, 139, 68, 139, 67,
  139, 13, 141, 12, 141, 11, 141, 10, 141, 9, 141, 8, 141, 7, 141,
  6, 141, 134, 110, 197, 110, 3, 17, 3, 17, 3, 17, 3, 17, 3,
  16, 3, 16, 3, 16, 3, 16, 2, 1, 2, 1, 2, 1, 2, 1,
  2, 1, 2, 1, 2, 1, 2, 1, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 196, 5, 33, 5,
  18, 5, 2, 3, 17, 3, 17, 3, 17, 3, 17, 3, 16, 3, 16,
  3, 16, 3, 16, 3, 1, 3, 1, 3, 1, 3, 1, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 34,
  32, 0, 196, 5, 33, 5, 18, 5, 2, 3, 1, 3, 1, 3, 1,
  3, 1, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2,
  17, 2, 17, 2, 16, 2, 16, 2, 16, 2, 16, 2, 16, 2, 16,
  2, 16, 2, 16, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2,
  0, 2, 0, 2, 0, 34, 32, 8, 51, 8, 50, 7, 35, 7, 35,
  6, 19, 6, 19, 6, 19, 6, 19, 7, 49, 7, 49, 7, 48, 7,
  48, 7, 3, 7, 3, 7, 34, 7, 34, 6, 33, 6, 33, 6, 33,
  6, 33, 6, 18, 6, 18, 6, 18, 6, 18, 6, 32, 6, 32, 6,
  32, 6, 32, 6, 2, 6, 2, 6, 2, 6, 2, 3, 17, 3, 17,
  3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3,
  17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17,
  3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3,
  17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17,
  3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
  16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
  3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
  16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
  3, 16, 3, 16, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 68, 32, 196, 5, 49,
  5, 19, 5, 34, 5, 32, 4, 33, 4, 33, 4, 18, 4, 18, 4,
  2, 4, 2, 3, 16, 3, 16, 3, 16, 3, 16, 2, 17, 2, 17,
  2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 0, 3, 0, 3, 0, 3, 0, 194, 50,
  51, 48, 35, 3, 0, 32, 64, 224, 64, 224, 8, 81, 8, 21, 0,
  224, 8, 5, 224, 223, 8, 66, 8, 36, 7, 65, 7, 65, 7, 20,
  7, 20, 7, 4, 7, 4, 8, 64, 8, 50, 8, 35, 8, 48, 7,
  49, 7, 49, 7, 19, 7, 19, 7, 3, 7, 3, 7, 34, 7, 34,
  6, 33, 6, 33, 6, 33, 6, 33, 5, 18, 5, 18, 5, 18, 5,
  18, 5, 18, 5, 18, 5, 18, 5, 18, 6, 32, 6, 32, 6, 32,
  6, 32, 6, 2, 6, 2, 6, 2, 6, 2, 4, 17, 4, 17, 4,
  17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17,
  4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 3, 16, 3,
  16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
  3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
  16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
  3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
  16, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 196, 193, 69, 53, 85, 84, 83, 68, 82,
  37, 80, 67, 52, 51, 0, 96, 64, 96, 96, 224, 8, 81, 8, 21,
  32, 224, 32, 224, 8, 66, 8, 36, 8, 65, 7, 20, 7, 20, 8,
  64, 8, 4, 8, 50, 8, 35, 8, 49, 8, 19, 8, 48, 8, 3,
  6, 34, 6, 34, 6, 34, 6, 34, 6, 32, 6, 32, 6, 32, 6,
  32, 6, 2, 6, 2, 6, 2, 6, 2, 4, 33, 4, 33, 4, 33,
  4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4,
  33, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4, 18, 4, 18,
  4, 18, 4, 18, 4, 18, 4, 18, 4, 18, 4, 18, 4, 18, 4,
  18, 4, 18, 4, 18, 4, 18, 4, 18, 4, 18, 4, 18, 2, 17,
  2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2,
  17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17,
  2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2,
  17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17,
  2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2,
  17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17,
  2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2,
  17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17, 2, 17,
  2, 17, 2, 17, 2, 17, 3, 16, 3, 16, 3, 16, 3, 16, 3,
  16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
  3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
  16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
  3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 2,
  0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
  2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2,
  0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
  2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2,
  0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
  2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2,
  0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
  2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2,
  0, 2, 0, 2, 0, 2, 0, 66, 53, 194, 84, 85, 69, 194, 82,
  83, 68, 37, 80, 67, 52, 5, 51, 0, 224, 8, 83, 8, 53, 192,
  223, 8, 68, 8, 82, 8, 37, 8, 81, 7, 21, 7, 21, 7, 67,
  7, 67, 7, 52, 7, 52, 8, 5, 8, 64, 7, 66, 7, 66, 7,
  36, 7, 36, 7, 51, 7, 51, 7, 4, 7, 4, 6, 65, 6, 65,
  6, 65, 6, 65, 6, 20, 6, 20, 6, 20, 6, 20, 6, 50, 6,
  50, 6, 50, 6, 50, 6, 35, 6, 35, 6, 35, 6, 35, 5, 49,
  5, 49, 5, 49, 5, 49, 5, 49, 5, 49, 5, 49, 5, 49, 5,
  19, 5, 19, 5, 19, 5, 19, 5, 19, 5, 19, 5, 19, 5, 19,
  6, 48, 6, 48, 6, 48, 6, 48, 6, 3, 6, 3, 6, 3, 6,
  3, 5, 34, 5, 34, 5, 34, 5, 34, 5, 34, 5, 34, 5, 34,
  5, 34, 5, 32, 5, 32, 5, 32, 5, 32, 5, 32, 5, 32, 5,
  32, 5, 32, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33,
  4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4,
  33, 4, 33, 4, 33, 4, 18, 4, 18, 4, 18, 4, 18, 4, 18,
  4, 18, 4, 18, 4, 18, 4, 18, 4, 18, 4, 18, 4, 18, 4,
  18, 4, 18, 4, 18, 4, 18, 4, 2, 4, 2, 4, 2, 4, 2,
  4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4, 2, 4,
  2, 4, 2, 4, 2, 4, 2, 4, 2, 3, 17, 3, 17, 3, 17,
  3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3,
  17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17,
  3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3,
  17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 16,
  3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
  16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
  3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
  16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
  3, 16, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 0, 3, 0, 3, 0, 3, 0, 3,
  0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0,
  3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3,
  0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0,
  3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 85, 84, 69, 80, 0,
  32, 160, 32, 224, 32, 64, 225, 64, 97, 96, 161, 128, 161, 8, 113,
  8, 23, 96, 225, 96, 97, 128, 161, 8, 97, 8, 22, 8, 6, 64,
  225, 64, 225, 64, 225, 8, 65, 8, 20, 8, 4, 8, 50, 8, 35,
  8, 48, 7, 49, 7, 49, 7, 19, 7, 19, 7, 3, 7, 3, 7,
  34, 7, 34, 6, 33, 6, 33, 6, 33, 6, 33, 6, 18, 6, 18,
  6, 18, 6, 18, 6, 32, 6, 32, 6, 32, 6, 32, 6, 2, 6,
  2, 6, 2, 6, 2, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17,
  4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4,
  17, 4, 17, 4, 17, 4, 17, 3, 16, 3, 16, 3, 16, 3, 16,
  3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
  16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
  3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
  16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 6, 65, 194, 116, 87, 102, 196, 193, 103, 117, 119, 118, 196, 193,
  86, 115, 71, 101, 198, 65, 194, 54, 85, 69, 55, 100, 114, 39, 194,
  7, 70, 112, 38, 193, 84, 83, 96, 193, 53, 68, 99, 98, 194, 81,
  82, 37, 21, 193, 67, 52, 80, 5, 66, 36, 51, 64, 0, 32, 64,
  32, 160, 96, 192, 224, 192, 32, 8, 114, 8, 39, 192, 224, 7, 23,
  7, 23, 8, 113, 8, 7, 8, 99, 8, 54, 8, 6, 224, 223, 224,
  223, 8, 81, 7, 38, 7, 38, 8, 98, 8, 96, 7, 97, 7, 97,
  7, 22, 7, 22, 8, 21, 8, 67, 8, 5, 96, 222, 8, 66, 8,
  36, 8, 65, 8, 20, 8, 64, 8, 4, 7, 50, 7, 50, 7, 35,
  7, 35, 6, 49, 6, 49, 6, 49, 6, 49, 6, 19, 6, 19, 6,
  19, 6, 19, 7, 48, 7, 48, 7, 3, 7, 3, 6, 34, 6, 34,
  6, 34, 6, 34, 5, 18, 5, 18, 5, 18, 5, 18, 5, 18, 5,
  18, 5, 18, 5, 18, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33,
  4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4,
  33, 4, 33, 4, 33, 4, 33, 5, 32, 5, 32, 5, 32, 5, 32,
  5, 32, 5, 32, 5, 32, 5, 32, 5, 2, 5, 2, 5, 2, 5,
  2, 5, 2, 5, 2, 5, 2, 5, 2, 3, 17, 3, 17, 3, 17,
  3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3,
  17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17,
  3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3,
  17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 16,
  3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
  16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
  3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
  16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
  3, 16, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 2, 0, 2, 0, 2, 0, 2, 0, 2,
  0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
  2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2,
  0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
  2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2,
  0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
  2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2,
  0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0,
  2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 196,
  193, 103, 87, 119, 118, 198, 129, 71, 193, 117, 85, 102, 116, 194, 115,
  101, 86, 55, 100, 196, 193, 83, 53, 84, 69, 70, 112, 68, 82, 37,
  80, 52, 51, 0, 96, 32, 224, 32, 224, 32, 224, 8, 101, 8, 115,
  224, 223, 8, 114, 8, 39, 8, 100, 8, 70, 8, 113, 8, 23, 32,
  223, 8, 99, 8, 54, 8, 84, 8, 69, 8, 68, 128, 222, 7, 98,
  7, 98, 7, 38, 7, 38, 7, 22, 7, 22, 8, 97, 8, 6, 8,
  83, 8, 53, 8, 82, 8, 37, 7, 81, 7, 81, 7, 21, 7, 21,
  7, 67, 7, 67, 7, 52, 7, 52, 8, 5, 8, 64, 7, 66, 7,
  66, 7, 36, 7, 36, 7, 65, 7, 65, 6, 51, 6, 51, 6, 51,
  6, 51, 6, 20, 6, 20, 6, 20, 6, 20, 6, 50, 6, 50, 6,
  50, 6, 50, 6, 35, 6, 35, 6, 35, 6, 35, 7, 4, 7, 4,
  7, 48, 7, 48, 6, 3, 6, 3, 6, 3, 6, 3, 5, 49, 5,
  49, 5, 49, 5, 49, 5, 49, 5, 49, 5, 49, 5, 49, 5, 19,
  5, 19, 5, 19, 5, 19, 5, 19, 5, 19, 5, 19, 5, 19, 5,
  34, 5, 34, 5, 34, 5, 34, 5, 34, 5, 34, 5, 34, 5, 34,
  4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4,
  33, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33, 4, 33,
  4, 33, 4, 18, 4, 18, 4, 18, 4, 18, 4, 18, 4, 18, 4,
  18, 4, 18, 4, 18, 4, 18, 4, 18, 4, 18, 4, 18, 4, 18,
  4, 18, 4, 18, 5, 32, 5, 32, 5, 32, 5, 32, 5, 32, 5,
  32, 5, 32, 5, 32, 5, 2, 5, 2, 5, 2, 5, 2, 5, 2,
  5, 2, 5, 2, 5, 2, 4, 0, 4, 0, 4, 0, 4, 0, 4,
  0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0,
  4, 0, 4, 0, 4, 0, 4, 0, 3, 17, 3, 17, 3, 17, 3,
  17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17,
  3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3,
  17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17,
  3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 16, 3,
  16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
  3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
  16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16,
  3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3, 16, 3,
  16, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 194, 103, 119, 118, 117, 87, 102, 116, 71, 86,
  55, 85, 112, 7, 96, 80, 0, 32, 96, 41, 96, 44, 128, 46, 160,
  47, 224, 48, 224, 49, 96, 50, 224, 50, 64, 51, 224, 51, 64, 52,
  224, 244, 224, 52, 32, 117, 96, 245, 96, 117, 128, 181, 160, 53, 224,
  53, 8, 24, 0, 246, 0, 246, 0, 246, 0, 118, 32, 246, 8, 81,
  8, 21, 224, 245, 224, 245, 224, 245, 8, 65, 7, 20, 7, 20, 8,
  64, 8, 4, 8, 50, 8, 35, 7, 49, 7, 49, 7, 19, 7, 19,
  7, 48, 7, 48, 7, 3, 7, 3, 7, 34, 7, 34, 6, 33, 6,
  33, 6, 33, 6, 33, 6, 18, 6, 18, 6, 18, 6, 18, 6, 32,
  6, 32, 6, 32, 6, 32, 6, 2, 6, 2, 6, 2, 6, 2, 4,
  17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17,
  4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4,
  17, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16,
  4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4,
  16, 4, 16, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 38, 1, 16, 1, 4, 193, 241,
  31, 70, 129, 155, 193, 185, 170, 194, 227, 140, 109, 12, 1, 70, 65,
  194, 228, 215, 125, 194, 186, 156, 229, 198, 65, 194, 240, 230, 201, 242,
  47, 32, 1, 16, 1, 6, 129, 243, 193, 216, 141, 198, 65, 194, 63,
  172, 110, 244, 79, 8, 1, 196, 193, 202, 187, 95, 126, 196, 193, 217,
  157, 142, 245, 30, 1, 12, 1, 134, 65, 194, 246, 188, 111, 173, 193,
  218, 203, 8, 65, 130, 127, 232, 193, 247, 231, 198, 129, 204, 193, 234,
  233, 248, 143, 18, 1, 8, 1, 196, 193, 219, 189, 159, 174, 68, 193,
  190, 249, 194, 235, 175, 220, 14, 1, 4, 193, 206, 221, 198, 129, 205,
  193, 250, 158, 191, 236, 8, 1, 196, 193, 237, 251, 238, 252, 68, 193,
  254, 253, 66, 255, 66, 222, 194, 223, 239, 207, 28, 1, 12, 1, 4,
  193, 108, 211, 196, 193, 154, 198, 77, 169, 8, 1, 196, 193, 184, 139,
  124, 212, 196, 193, 93, 199, 14, 213, 10, 1, 132, 193, 225, 30, 46,
  193, 226, 224, 136, 1, 196, 193, 214, 62, 78, 200, 15, 193, 171, 94,
  16, 1, 72, 1, 196, 193, 168, 138, 208, 13, 66, 29, 194, 180, 122,
  121, 12, 1, 134, 65, 194, 60, 153, 167, 123, 193, 197, 92, 68, 193,
  45, 209, 194, 210, 61, 183, 10, 1, 198, 65, 194, 193, 91, 152, 44,
  181, 4, 193, 195, 194, 196, 193, 182, 107, 196, 76, 12, 1, 70, 129,
  59, 193, 136, 165, 194, 179, 106, 151, 134, 129, 12, 193, 75, 166, 28,
  193, 137, 192, 8, 65, 130, 43, 73, 193, 119, 103, 134, 129, 74, 193,
  135, 120, 178, 193, 90, 150, 200, 1, 196, 193, 105, 164, 176, 11, 177,
  27, 4, 193, 162, 42, 196, 193, 149, 89, 163, 58, 198, 65, 194, 10,
  160, 134, 161, 26, 72, 1, 196, 193, 88, 118, 147, 133, 194, 57, 104,
  148, 198, 65, 194, 131, 117, 87, 146, 41, 136, 1, 196, 193, 86, 55,
  71, 101, 56, 193, 102, 116, 145, 25, 196, 193, 132, 72, 144, 9, 130,
  130, 39, 193, 100, 70, 40, 129, 194, 113, 115, 114, 23, 193, 85, 112,
  196, 193, 54, 84, 7, 99, 196, 193, 38, 83, 69, 98, 128, 8, 97,
  22, 96, 6, 194, 82, 53, 68, 37, 80, 67, 52, 5, 66, 36, 51,
  0, 32, 128, 34, 96, 36, 96, 37, 64, 38, 32, 39, 224, 39, 160,
  40, 128, 41, 32, 42, 160, 42, 0, 43, 96, 43, 160, 43, 0, 44,
  96, 172, 128, 44, 192, 44, 0, 109, 32, 45, 96, 173, 128, 173, 160,
  45, 224, 109, 0, 238, 0, 238, 0, 238, 0, 110, 32, 238, 32, 238,
  32, 174, 64, 238, 64, 238, 64, 238, 8, 25, 32, 238, 32, 238, 32,
  238, 32, 238, 32, 238, 8, 130, 8, 40, 8, 129, 8, 24, 160, 237,
  160, 237, 160, 237, 160, 237, 8, 114, 8, 39, 8, 70, 8, 113, 8,
  85, 8, 23, 224, 236, 8, 99, 8, 54, 8, 84, 8, 69, 8, 98,
  8, 38, 8, 97, 0, 236, 8, 83, 7, 22, 7, 22, 8, 53, 8,
  68, 7, 82, 7, 82, 7, 37, 7, 37, 7, 81, 7, 81, 7, 21,
  7, 21, 8, 80, 8, 5, 7, 67, 7, 67, 7, 52, 7, 52, 7,
  66, 7, 66, 7, 36, 7, 36, 7, 51, 7, 51, 6, 20, 6, 20,
  6, 20, 6, 20, 7, 65, 7, 65, 7, 64, 7, 64, 6, 50, 6,
  50, 6, 50, 6, 50, 6, 35, 6, 35, 6, 35, 6, 35, 7, 4,
  7, 4, 7, 48, 7, 48, 6, 49, 6, 49, 6, 49, 6, 49, 6,
  19, 6, 19, 6, 19, 6, 19, 6, 3, 6, 3, 6, 3, 6, 3,
  5, 34, 5, 34, 5, 34, 5, 34, 5, 34, 5, 34, 5, 34, 5,
  34, 5, 33, 5, 33, 5, 33, 5, 33, 5, 33, 5, 33, 5, 33,
  5, 33, 5, 18, 5, 18, 5, 18, 5, 18, 5, 18, 5, 18, 5,
  18, 5, 18, 5, 32, 5, 32, 5, 32, 5, 32, 5, 32, 5, 32,
  5, 32, 5, 32, 5, 2, 5, 2, 5, 2, 5, 2, 5, 2, 5,
  2, 5, 2, 5, 2, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17,
  3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3,
  17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17,
  3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 3,
  17, 3, 17, 3, 17, 3, 17, 3, 17, 4, 16, 4, 16, 4, 16,
  4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4,
  16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 1, 4, 1,
  4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4,
  1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 3, 0,
  3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3,
  0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0,
  3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3,
  0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0,
  3, 0, 16, 1, 8, 1, 196, 193, 205, 249, 190, 220, 196, 193, 175,
  235, 221, 250, 14, 1, 6, 129, 191, 193, 236, 206, 196, 193, 222, 251,
  207, 237, 6, 129, 238, 193, 223, 252, 196, 193, 239, 253, 255, 254, 18,
  1, 10, 1, 198, 129, 246, 193, 234, 240, 173, 203, 196, 193, 127, 218,
  158, 247, 8, 1, 196, 193, 204, 233, 248, 143, 196, 193, 219, 189, 159,
  174, 8, 1, 196, 193, 126, 202, 95, 231, 200, 1, 196, 193, 245, 217,
  232, 142, 188, 111, 8, 1, 196, 193, 63, 141, 79, 243, 198, 65, 194,
  244, 157, 216, 172, 187, 8, 1, 196, 193, 201, 156, 241, 31, 198, 129,
  47, 193, 230, 15, 110, 242, 8, 1, 196, 193, 228, 78, 215, 125, 196,
  193, 171, 94, 229, 186, 8, 1, 196, 193, 185, 155, 109, 62, 196, 193,
  227, 214, 200, 140, 10, 1, 132, 193, 213, 93, 30, 193, 224, 14, 196,
  193, 46, 225, 226, 170, 6, 129, 77, 193, 139, 169, 196, 193, 212, 184,
  199, 124, 4, 193, 61, 45, 196, 193, 108, 211, 154, 198, 68, 193, 183,
  123, 194, 209, 210, 208, 132, 193, 92, 168, 29, 193, 197, 13, 196, 193,
  76, 182, 138, 196, 132, 193, 195, 60, 107, 193, 153, 192, 198, 129, 106,
  193, 12, 176, 167, 122, 44, 193, 194, 181, 196, 193, 152, 137, 91, 193,
  196, 193, 75, 166, 28, 180, 194, 59, 179, 151, 196, 193, 178, 165, 121,
  136, 43, 193, 90, 177, 27, 193, 11, 150, 196, 193, 74, 135, 105, 164,
  194, 58, 120, 163, 149, 89, 162, 42, 161, 26, 194, 134, 160, 10, 104,
  148, 73, 147, 57, 193, 119, 144, 133, 88, 146, 118, 103, 41, 145, 9,
  132, 72, 117, 87, 131, 56, 102, 116, 71, 128, 8, 101, 86, 115, 55,
  100, 112, 7, 96, 6, 0, 32, 192, 32, 64, 33, 8, 255, 96, 97,
  128, 225, 128, 161, 8, 47, 128, 228, 8, 241, 8, 31, 64, 36, 96,
  41, 0, 44, 160, 45, 224, 46, 64, 48, 64, 49, 224, 49, 64, 50,
  224, 50, 96, 51, 192, 51, 32, 116, 96, 180, 128, 52, 192, 244, 192,
  180, 224, 180, 0, 245, 8, 21, 224, 244, 224, 244, 224, 244, 224, 244,
  8, 65, 8, 20, 160, 244, 8, 50, 8, 35, 7, 49, 7, 49, 7,
  19, 7, 19, 8, 48, 8, 3, 7, 34, 7, 34, 6, 33, 6, 33,
  6, 33, 6, 33, 6, 18, 6, 18, 6, 18, 6, 18, 6, 32, 6,
  32, 6, 32, 6, 32, 6, 2, 6, 2, 6, 2, 6, 2, 4, 17,
  4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4,
  17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17,
  4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4,
  16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16,
  4, 16, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
  1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
  3, 1, 3, 1, 3, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 8, 1, 196, 193, 251, 191, 252, 207,
  196, 193, 253, 223, 254, 239, 134, 65, 194, 248, 159, 143, 250, 193, 175,
  249, 196, 193, 246, 111, 247, 127, 194, 244, 245, 95, 79, 63, 15, 129,
  243, 1, 20, 1, 8, 65, 66, 219, 194, 229, 156, 215, 134, 65, 194,
  172, 231, 202, 204, 193, 218, 173, 10, 1, 198, 65, 194, 234, 205, 189,
  235, 220, 6, 129, 238, 193, 222, 190, 70, 129, 158, 193, 174, 157, 130,
  237, 236, 193, 206, 221, 242, 240, 36, 1, 16, 1, 8, 1, 196, 193,
  212, 184, 199, 124, 196, 193, 213, 93, 224, 14, 8, 65, 130, 62, 183,
  193, 123, 13, 70, 129, 77, 193, 139, 154, 194, 30, 155, 170, 24, 1,
  10, 1, 198, 129, 214, 193, 109, 185, 140, 227, 6, 129, 228, 193, 78,
  200, 196, 193, 94, 125, 186, 171, 12, 1, 4, 193, 110, 201, 196, 193,
  141, 230, 187, 216, 136, 1, 196, 193, 217, 126, 232, 142, 233, 193, 203,
  188, 18, 1, 6, 129, 46, 193, 226, 225, 70, 129, 12, 193, 137, 151,
  194, 193, 181, 152, 14, 1, 6, 65, 194, 195, 107, 167, 196, 193, 153,
  196, 168, 138, 6, 65, 194, 208, 197, 92, 196, 193, 108, 211, 169, 198,
  14, 1, 6, 129, 194, 193, 44, 91, 196, 193, 60, 122, 76, 182, 8,
  65, 130, 209, 179, 193, 121, 136, 196, 193, 45, 29, 61, 210, 10, 1,
  68, 193, 43, 177, 194, 178, 165, 90, 6, 65, 194, 59, 166, 106, 196,
  193, 180, 75, 28, 192, 12, 1, 70, 65, 194, 162, 163, 149, 194, 58,
  135, 120, 136, 1, 196, 193, 164, 74, 150, 105, 27, 193, 176, 11, 8,
  65, 66, 42, 194, 118, 148, 117, 70, 65, 194, 73, 104, 119, 194, 26,
  89, 134, 136, 1, 196, 193, 133, 88, 147, 57, 161, 193, 160, 10, 198,
  65, 194, 145, 103, 144, 146, 41, 136, 1, 196, 193, 131, 56, 72, 87,
  25, 193, 9, 132, 70, 65, 194, 129, 116, 71, 194, 40, 102, 130, 198,
  65, 194, 115, 128, 101, 24, 8, 132, 193, 114, 39, 55, 193, 86, 100,
  66, 113, 194, 112, 70, 85, 23, 193, 7, 99, 196, 193, 69, 98, 54,
  84, 38, 97, 22, 193, 96, 6, 53, 193, 83, 68, 82, 37, 81, 80,
  67, 52, 5, 66, 36, 51, 64, 4, 8, 254, 8, 239, 8, 253, 8,
  223, 8, 252, 8, 207, 8, 251, 8, 191, 7, 175, 7, 175, 8, 250,
  8, 249, 7, 159, 7, 159, 7, 143, 7, 143, 8, 248, 8, 247, 7,
  127, 7, 127, 7, 246, 7, 246, 7, 111, 7, 111, 7, 245, 7, 245,
  7, 95, 7, 95, 7, 244, 7, 244, 7, 79, 7, 79, 7, 243, 7,
  243, 7, 63, 7, 63, 7, 242, 7, 242, 7, 47, 7, 47, 7, 31,
  7, 31, 8, 241, 8, 15, 128, 154, 224, 26, 160, 27, 96, 28, 4,
  255, 4, 255, 4, 255, 4, 255, 4, 255, 4, 255, 4, 255, 4, 255,
  4, 255, 4, 255, 4, 255, 4, 255, 4, 255, 4, 255, 4, 255, 4,
  255, 32, 27, 224, 27, 64, 28, 160, 28, 0, 29, 64, 29, 128, 29,
  192, 29, 0, 30, 64, 30, 128, 30, 192, 30, 0, 31, 64, 31, 160,
  31, 224, 31, 32, 32, 96, 32, 224, 160, 0, 33, 96, 225, 96, 97,
  128, 33, 192, 225, 192, 97, 224, 225, 224, 225, 224, 225, 224, 225, 224,
  225, 224, 225, 224, 225, 224, 225, 224, 225, 224, 225, 224, 225, 224, 225,
  224, 225, 224, 225, 224, 225, 224, 225, 224, 225, 224, 161, 0, 226, 0,
  162, 8, 55, 0, 226, 8, 39, 8, 100, 8, 70, 8, 85, 8, 23,
  8, 99, 8, 54, 8, 84, 8, 69, 8, 98, 8, 38, 8, 97, 8,
  22, 96, 224, 8, 83, 8, 53, 8, 68, 8, 82, 8, 37, 8, 81,
  160, 223, 7, 21, 7, 21, 8, 67, 8, 52, 7, 66, 7, 66, 7,
  36, 7, 36, 7, 51, 7, 51, 7, 65, 7, 65, 7, 20, 7, 20,
  8, 64, 8, 4, 7, 50, 7, 50, 7, 35, 7, 35, 6, 49, 6,
  49, 6, 49, 6, 49, 6, 19, 6, 19, 6, 19, 6, 19, 7, 48,
  7, 48, 7, 3, 7, 3, 6, 34, 6, 34, 6, 34, 6, 34, 5,
  33, 5, 33, 5, 33, 5, 33, 5, 33, 5, 33, 5, 33, 5, 33,
  5, 18, 5, 18, 5, 18, 5, 18, 5, 18, 5, 18, 5, 18, 5,
  18, 6, 32, 6, 32, 6, 32, 6, 32, 6, 2, 6, 2, 6, 2,
  6, 2, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4,
  17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17, 4, 17,
  4, 17, 4, 17, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4,
  16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16, 4, 16,
  4, 16, 4, 16, 4, 16, 4, 1, 4, 1, 4, 1, 4, 1, 4,
  1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
  4, 1, 4, 1, 4, 1, 4, 1, 4, 0, 4, 0, 4, 0, 4,
  0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0,
  4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 240, 1, 196, 193, 222,
  236, 238, 237, 8, 1, 196, 193, 234, 174, 220, 205, 196, 193, 235, 190,
  206, 221, 8, 1, 196, 193, 173, 203, 158, 218, 196, 193, 204, 233, 219,
  189, 8, 1, 196, 193, 126, 202, 157, 231, 196, 193, 142, 217, 188, 232,
  8, 65, 66, 110, 194, 208, 224, 14, 196, 193, 216, 141, 172, 187, 68,
  193, 229, 171, 194, 156, 230, 201, 132, 193, 125, 78, 94, 193, 186, 215,
  198, 65, 194, 227, 228, 226, 200, 140, 196, 193, 62, 185, 214, 109, 196,
  193, 46, 225, 155, 170, 196, 193, 93, 199, 30, 213, 196, 193, 184, 139,
  124, 212, 196, 193, 154, 198, 77, 169, 196, 193, 61, 210, 108, 211, 196,
  193, 183, 123, 45, 209, 196, 193, 92, 168, 29, 197, 196, 193, 196, 76,
  138, 153, 198, 65, 194, 195, 13, 192, 182, 107, 196, 193, 122, 194, 60,
  167, 196, 193, 91, 193, 44, 181, 196, 193, 28, 180, 152, 137, 70, 65,
  194, 161, 11, 160, 194, 179, 12, 176, 75, 193, 166, 106, 198, 65, 194,
  9, 10, 144, 151, 121, 59, 136, 194, 43, 178, 165, 196, 193, 27, 150,
  90, 177, 105, 74, 194, 120, 164, 135, 163, 58, 149, 89, 162, 42, 26,
  134, 104, 119, 148, 73, 147, 57, 133, 88, 146, 118, 103, 41, 145, 25,
  132, 72, 117, 87, 131, 56, 102, 130, 40, 129, 116, 71, 24, 193, 128,
  8, 101, 86, 113, 193, 112, 7, 115, 114, 96, 6, 80, 5, 6, 187,
  6, 255, 6, 221, 6, 238, 6, 119, 6, 85, 5, 153, 5, 153, 5,
  102, 5, 102, 5, 51, 5, 51, 5, 170, 5, 170, 5, 204, 5, 204,
  4, 34, 4, 34, 4, 34, 4, 34, 4, 17, 4, 17, 4, 17, 4,
  17, 4, 68, 4, 68, 4, 68, 4, 68, 4, 136, 4, 136, 4, 136,
  4, 136, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
  1, 0, 1, 0, 1, 0, 4, 255, 4, 255, 4, 255, 4, 255, 4,
  238, 4, 238, 4, 238, 4, 238, 4, 221, 4, 221, 4, 221, 4, 221,
  4, 204, 4, 204, 4, 204, 4, 204, 4, 187, 4, 187, 4, 187, 4,
  187, 4, 170, 4, 170, 4, 170, 4, 170, 4, 153, 4, 153, 4, 153,
  4, 153, 4, 136, 4, 136, 4, 136, 4, 136, 4, 119, 4, 119, 4,
  119, 4, 119, 4, 102, 4, 102, 4, 102, 4, 102, 4, 85, 4, 85,
  4, 85, 4, 85, 4, 68, 4, 68, 4, 68, 4, 68, 4, 51, 4,
  51, 4, 51, 4, 51, 4, 34, 4, 34, 4, 34, 4, 34, 4, 17,
  4, 17, 4, 17, 4, 17, 4, 0, 4, 0, 4, 0, 4, 0,
};

// linear escape bits

static const S32 h_linbits[34] =
   {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,6,8,10,13,4,5,6,7,8,9,11,13,-1,-1};

//
// Boundaries of each scalefactor band (layer 3)
//
// 21 bands at each sampling frequency for long (type 0,1,3) windows
// 12 bands each for short windows
//
// [MPEG version][sampling frequency][band boundary]
//

static const S16 sf_bound_l[2][3][22] =
{
   {
      { 5,11,17,23,29,35,43,53,65,79,95,115,139,167,199,237,283,335,395,463,521,575 },
      { 5,11,17,23,29,35,43,53,65,79,95,113,135,161,193,231,277,331,393,463,539,575 },
      { 5,11,17,23,29,35,43,53,65,79,95,115,139,167,199,237,283,335,395,463,521,575 }
   },
   {
      { 3,7,11,15,19,23,29,35,43,51,61,73, 89,109,133,161,195,237,287,341,417,575 },
      { 3,7,11,15,19,23,29,35,41,49,59,71, 87,105,127,155,189,229,275,329,383,575 },
      { 3,7,11,15,19,23,29,35,43,53,65,81,101,125,155,193,239,295,363,447,549,575 }
   }
};

static const S16 sf_bound_s[2][3][13] =
{
   {
      { 3,7,11,17,23,31,41,55,73, 99,131,173,191},
      { 3,7,11,17,25,35,47,61,79,103,135,179,191},
      { 3,7,11,17,25,35,47,61,79,103,133,173,191}
   },
   {
      { 3,7,11,15,21,29,39,51,65, 83,105,135,191},
      { 3,7,11,15,21,27,37,49,63, 79, 99,125,191},
      { 3,7,11,15,21,29,41,57,77,103,137,179,191}
   }
};

//
// Scalefactor band tables from reference source
//

static const struct
{
   S16 l[23];
   S16 s[14];
}
sfBandIndex[6] =
   {{{0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
     {0,4,8,12,18,24,32,42,56,74,100,132,174,192}},
    {{0,6,12,18,24,30,36,44,54,66,80,96,114,136,162,194,232,278,330,394,464,540,576},
     {0,4,8,12,18,26,36,48,62,80,104,136,180,192}},
    {{0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
     {0,4,8,12,18,26,36,48,62,80,104,134,174,192}},

    {{0,4,8,12,16,20,24,30,36,44,52,62,74,90,110,134,162,196,238,288,342,418,576},
     {0,4,8,12,16,22,30,40,52,66,84,106,136,192}},
    {{0,4,8,12,16,20,24,30,36,42,50,60,72,88,106,128,156,190,230,276,330,384,576},
     {0,4,8,12,16,22,28,38,50,64,80,100,126,192}},
    {{0,4,8,12,16,20,24,30,36,44,54,66,82,102,126,156,194,240,296,364,448,550,576},
     {0,4,8,12,16,22,30,42,58,78,104,138,180,192}}};

static const struct
{
   S32 l[5];
   S32 s[3];
}
sfbtable = {{0, 6, 11, 16, 21},
            {0, 6, 12}};

static const S32 slen[2][16] = {{0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4},
                   {0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3}};


//
// Forward-transform dest=[mpeg version][sfreq][src]
//

static const S16 reord_ft[2][3][576] =
{{
{  0,   1,   2,   3,   6,   7,   8,   9,  12,  13,  14,  15,   4,   5,  18,  19,  10,  11,  24,  25,
  16,  17,  30,  31,  20,  21,  22,  23,  26,  27,  28,  29,  32,  33,  34,  35,  36,  37,  38,  39,
  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  90,  91,
  78,  79,  80,  81,  82,  83,  96,  97,  84,  85,  86,  87,  88,  89, 102, 103,  92,  93,  94,  95,
 108, 109, 110, 111, 112, 113,  98,  99, 100, 101, 114, 115, 116, 117, 118, 119, 104, 105, 106, 107,
 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 144, 145, 146, 147, 148, 149, 162, 163,
 132, 133, 134, 135, 136, 137, 150, 151, 152, 153, 154, 155, 168, 169, 138, 139, 140, 141, 142, 143,
 156, 157, 158, 159, 160, 161, 174, 175, 164, 165, 166, 167, 180, 181, 182, 183, 184, 185, 198, 199,
 200, 201, 202, 203, 216, 217, 170, 171, 172, 173, 186, 187, 188, 189, 190, 191, 204, 205, 206, 207,
 208, 209, 222, 223, 176, 177, 178, 179, 192, 193, 194, 195, 196, 197, 210, 211, 212, 213, 214, 215,
 228, 229, 218, 219, 220, 221, 234, 235, 236, 237, 238, 239, 252, 253, 254, 255, 256, 257, 270, 271,
 272, 273, 274, 275, 288, 289, 290, 291, 224, 225, 226, 227, 240, 241, 242, 243, 244, 245, 258, 259,
 260, 261, 262, 263, 276, 277, 278, 279, 280, 281, 294, 295, 296, 297, 230, 231, 232, 233, 246, 247,
 248, 249, 250, 251, 264, 265, 266, 267, 268, 269, 282, 283, 284, 285, 286, 287, 300, 301, 302, 303,
 292, 293, 306, 307, 308, 309, 310, 311, 324, 325, 326, 327, 328, 329, 342, 343, 344, 345, 346, 347,
 360, 361, 362, 363, 364, 365, 378, 379, 380, 381, 382, 383, 298, 299, 312, 313, 314, 315, 316, 317,
 330, 331, 332, 333, 334, 335, 348, 349, 350, 351, 352, 353, 366, 367, 368, 369, 370, 371, 384, 385,
 386, 387, 388, 389, 304, 305, 318, 319, 320, 321, 322, 323, 336, 337, 338, 339, 340, 341, 354, 355,
 356, 357, 358, 359, 372, 373, 374, 375, 376, 377, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399,
 400, 401, 414, 415, 416, 417, 418, 419, 432, 433, 434, 435, 436, 437, 450, 451, 452, 453, 454, 455,
 468, 469, 470, 471, 472, 473, 486, 487, 488, 489, 490, 491, 504, 505, 506, 507, 508, 509, 402, 403,
 404, 405, 406, 407, 420, 421, 422, 423, 424, 425, 438, 439, 440, 441, 442, 443, 456, 457, 458, 459,
 460, 461, 474, 475, 476, 477, 478, 479, 492, 493, 494, 495, 496, 497, 510, 511, 512, 513, 514, 515,
 408, 409, 410, 411, 412, 413, 426, 427, 428, 429, 430, 431, 444, 445, 446, 447, 448, 449, 462, 463,
 464, 465, 466, 467, 480, 481, 482, 483, 484, 485, 498, 499, 500, 501, 502, 503, 516, 517, 518, 519,
 520, 521, 522, 523, 524, 525, 526, 527, 540, 541, 542, 543, 544, 545, 558, 559, 560, 561, 562, 563,
 528, 529, 530, 531, 532, 533, 546, 547, 548, 549, 550, 551, 564, 565, 566, 567, 568, 569, 534, 535,
 536, 537, 538, 539, 552, 553, 554, 555, 556, 557, 570, 571, 572, 573, 574, 575},

{  0,   1,   2,   3,   6,   7,   8,   9,  12,  13,  14,  15,   4,   5,  18,  19,  10,  11,  24,  25,
  16,  17,  30,  31,  20,  21,  22,  23,  26,  27,  28,  29,  32,  33,  34,  35,  36,  37,  38,  39,
  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
  72,  73,  60,  61,  62,  63,  64,  65,  78,  79,  66,  67,  68,  69,  70,  71,  84,  85,  74,  75,
  76,  77,  90,  91,  92,  93,  94,  95,  80,  81,  82,  83,  96,  97,  98,  99, 100, 101,  86,  87,
  88,  89, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 126, 127, 128, 129, 130, 131,
 114, 115, 116, 117, 118, 119, 132, 133, 134, 135, 136, 137, 120, 121, 122, 123, 124, 125, 138, 139,
 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 162, 163, 164, 165, 166, 167, 180, 181, 150, 151,
 152, 153, 154, 155, 168, 169, 170, 171, 172, 173, 186, 187, 156, 157, 158, 159, 160, 161, 174, 175,
 176, 177, 178, 179, 192, 193, 182, 183, 184, 185, 198, 199, 200, 201, 202, 203, 216, 217, 218, 219,
 220, 221, 234, 235, 188, 189, 190, 191, 204, 205, 206, 207, 208, 209, 222, 223, 224, 225, 226, 227,
 240, 241, 194, 195, 196, 197, 210, 211, 212, 213, 214, 215, 228, 229, 230, 231, 232, 233, 246, 247,
 236, 237, 238, 239, 252, 253, 254, 255, 256, 257, 270, 271, 272, 273, 274, 275, 288, 289, 290, 291,
 292, 293, 306, 307, 242, 243, 244, 245, 258, 259, 260, 261, 262, 263, 276, 277, 278, 279, 280, 281,
 294, 295, 296, 297, 298, 299, 312, 313, 248, 249, 250, 251, 264, 265, 266, 267, 268, 269, 282, 283,
 284, 285, 286, 287, 300, 301, 302, 303, 304, 305, 318, 319, 308, 309, 310, 311, 324, 325, 326, 327,
 328, 329, 342, 343, 344, 345, 346, 347, 360, 361, 362, 363, 364, 365, 378, 379, 380, 381, 382, 383,
 396, 397, 398, 399, 314, 315, 316, 317, 330, 331, 332, 333, 334, 335, 348, 349, 350, 351, 352, 353,
 366, 367, 368, 369, 370, 371, 384, 385, 386, 387, 388, 389, 402, 403, 404, 405, 320, 321, 322, 323,
 336, 337, 338, 339, 340, 341, 354, 355, 356, 357, 358, 359, 372, 373, 374, 375, 376, 377, 390, 391,
 392, 393, 394, 395, 408, 409, 410, 411, 400, 401, 414, 415, 416, 417, 418, 419, 432, 433, 434, 435,
 436, 437, 450, 451, 452, 453, 454, 455, 468, 469, 470, 471, 472, 473, 486, 487, 488, 489, 490, 491,
 504, 505, 506, 507, 508, 509, 522, 523, 524, 525, 526, 527, 406, 407, 420, 421, 422, 423, 424, 425,
 438, 439, 440, 441, 442, 443, 456, 457, 458, 459, 460, 461, 474, 475, 476, 477, 478, 479, 492, 493,
 494, 495, 496, 497, 510, 511, 512, 513, 514, 515, 528, 529, 530, 531, 532, 533, 412, 413, 426, 427,
 428, 429, 430, 431, 444, 445, 446, 447, 448, 449, 462, 463, 464, 465, 466, 467, 480, 481, 482, 483,
 484, 485, 498, 499, 500, 501, 502, 503, 516, 517, 518, 519, 520, 521, 534, 535, 536, 537, 538, 539,
 540, 541, 542, 543, 544, 545, 558, 559, 560, 561, 562, 563, 546, 547, 548, 549, 550, 551, 564, 565,
 566, 567, 568, 569, 552, 553, 554, 555, 556, 557, 570, 571, 572, 573, 574, 575},

{  0,   1,   2,   3,   6,   7,   8,   9,  12,  13,  14,  15,   4,   5,  18,  19,  10,  11,  24,  25,
  16,  17,  30,  31,  20,  21,  22,  23,  26,  27,  28,  29,  32,  33,  34,  35,  36,  37,  38,  39,
  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
  72,  73,  60,  61,  62,  63,  64,  65,  78,  79,  66,  67,  68,  69,  70,  71,  84,  85,  74,  75,
  76,  77,  90,  91,  92,  93,  94,  95,  80,  81,  82,  83,  96,  97,  98,  99, 100, 101,  86,  87,
  88,  89, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 126, 127, 128, 129, 130, 131,
 114, 115, 116, 117, 118, 119, 132, 133, 134, 135, 136, 137, 120, 121, 122, 123, 124, 125, 138, 139,
 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 162, 163, 164, 165, 166, 167, 180, 181, 150, 151,
 152, 153, 154, 155, 168, 169, 170, 171, 172, 173, 186, 187, 156, 157, 158, 159, 160, 161, 174, 175,
 176, 177, 178, 179, 192, 193, 182, 183, 184, 185, 198, 199, 200, 201, 202, 203, 216, 217, 218, 219,
 220, 221, 234, 235, 188, 189, 190, 191, 204, 205, 206, 207, 208, 209, 222, 223, 224, 225, 226, 227,
 240, 241, 194, 195, 196, 197, 210, 211, 212, 213, 214, 215, 228, 229, 230, 231, 232, 233, 246, 247,
 236, 237, 238, 239, 252, 253, 254, 255, 256, 257, 270, 271, 272, 273, 274, 275, 288, 289, 290, 291,
 292, 293, 306, 307, 242, 243, 244, 245, 258, 259, 260, 261, 262, 263, 276, 277, 278, 279, 280, 281,
 294, 295, 296, 297, 298, 299, 312, 313, 248, 249, 250, 251, 264, 265, 266, 267, 268, 269, 282, 283,
 284, 285, 286, 287, 300, 301, 302, 303, 304, 305, 318, 319, 308, 309, 310, 311, 324, 325, 326, 327,
 328, 329, 342, 343, 344, 345, 346, 347, 360, 361, 362, 363, 364, 365, 378, 379, 380, 381, 382, 383,
 396, 397, 314, 315, 316, 317, 330, 331, 332, 333, 334, 335, 348, 349, 350, 351, 352, 353, 366, 367,
 368, 369, 370, 371, 384, 385, 386, 387, 388, 389, 402, 403, 320, 321, 322, 323, 336, 337, 338, 339,
 340, 341, 354, 355, 356, 357, 358, 359, 372, 373, 374, 375, 376, 377, 390, 391, 392, 393, 394, 395,
 408, 409, 398, 399, 400, 401, 414, 415, 416, 417, 418, 419, 432, 433, 434, 435, 436, 437, 450, 451,
 452, 453, 454, 455, 468, 469, 470, 471, 472, 473, 486, 487, 488, 489, 490, 491, 504, 505, 506, 507,
 508, 509, 404, 405, 406, 407, 420, 421, 422, 423, 424, 425, 438, 439, 440, 441, 442, 443, 456, 457,
 458, 459, 460, 461, 474, 475, 476, 477, 478, 479, 492, 493, 494, 495, 496, 497, 510, 511, 512, 513,
 514, 515, 410, 411, 412, 413, 426, 427, 428, 429, 430, 431, 444, 445, 446, 447, 448, 449, 462, 463,
 464, 465, 466, 467, 480, 481, 482, 483, 484, 485, 498, 499, 500, 501, 502, 503, 516, 517, 518, 519,
 520, 521, 522, 523, 524, 525, 526, 527, 540, 541, 542, 543, 544, 545, 558, 559, 560, 561, 562, 563,
 528, 529, 530, 531, 532, 533, 546, 547, 548, 549, 550, 551, 564, 565, 566, 567, 568, 569, 534, 535,
 536, 537, 538, 539, 552, 553, 554, 555, 556, 557, 570, 571, 572, 573, 574, 575}
},
{
{  0,   1,   2,   3,   6,   7,   8,   9,  12,  13,  14,  15,   4,   5,  18,  19,  10,  11,  24,  25,
  16,  17,  30,  31,  20,  21,  22,  23,  26,  27,  28,  29,  32,  33,  34,  35,  36,  37,  38,  39,
  42,  43,  44,  45,  48,  49,  50,  51,  40,  41,  54,  55,  56,  57,  46,  47,  60,  61,  62,  63,
  52,  53,  66,  67,  68,  69,  58,  59,  72,  73,  74,  75,  76,  77,  64,  65,  78,  79,  80,  81,
  82,  83,  70,  71,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95, 108, 109, 110, 111,
  96,  97,  98,  99, 100, 101, 114, 115, 116, 117, 102, 103, 104, 105, 106, 107, 120, 121, 122, 123,
 112, 113, 126, 127, 128, 129, 130, 131, 144, 145, 146, 147, 118, 119, 132, 133, 134, 135, 136, 137,
 150, 151, 152, 153, 124, 125, 138, 139, 140, 141, 142, 143, 156, 157, 158, 159, 148, 149, 162, 163,
 164, 165, 166, 167, 180, 181, 182, 183, 184, 185, 154, 155, 168, 169, 170, 171, 172, 173, 186, 187,
 188, 189, 190, 191, 160, 161, 174, 175, 176, 177, 178, 179, 192, 193, 194, 195, 196, 197, 198, 199,
 200, 201, 202, 203, 216, 217, 218, 219, 220, 221, 234, 235, 236, 237, 238, 239, 204, 205, 206, 207,
 208, 209, 222, 223, 224, 225, 226, 227, 240, 241, 242, 243, 244, 245, 210, 211, 212, 213, 214, 215,
 228, 229, 230, 231, 232, 233, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 270, 271,
 272, 273, 274, 275, 288, 289, 290, 291, 292, 293, 306, 307, 308, 309, 258, 259, 260, 261, 262, 263,
 276, 277, 278, 279, 280, 281, 294, 295, 296, 297, 298, 299, 312, 313, 314, 315, 264, 265, 266, 267,
 268, 269, 282, 283, 284, 285, 286, 287, 300, 301, 302, 303, 304, 305, 318, 319, 320, 321, 310, 311,
 324, 325, 326, 327, 328, 329, 342, 343, 344, 345, 346, 347, 360, 361, 362, 363, 364, 365, 378, 379,
 380, 381, 382, 383, 396, 397, 398, 399, 316, 317, 330, 331, 332, 333, 334, 335, 348, 349, 350, 351,
 352, 353, 366, 367, 368, 369, 370, 371, 384, 385, 386, 387, 388, 389, 402, 403, 404, 405, 322, 323,
 336, 337, 338, 339, 340, 341, 354, 355, 356, 357, 358, 359, 372, 373, 374, 375, 376, 377, 390, 391,
 392, 393, 394, 395, 408, 409, 410, 411, 400, 401, 414, 415, 416, 417, 418, 419, 432, 433, 434, 435,
 436, 437, 450, 451, 452, 453, 454, 455, 468, 469, 470, 471, 472, 473, 486, 487, 488, 489, 490, 491,
 504, 505, 506, 507, 508, 509, 522, 523, 524, 525, 526, 527, 540, 541, 542, 543, 544, 545, 558, 559,
 560, 561, 562, 563, 406, 407, 420, 421, 422, 423, 424, 425, 438, 439, 440, 441, 442, 443, 456, 457,
 458, 459, 460, 461, 474, 475, 476, 477, 478, 479, 492, 493, 494, 495, 496, 497, 510, 511, 512, 513,
 514, 515, 528, 529, 530, 531, 532, 533, 546, 547, 548, 549, 550, 551, 564, 565, 566, 567, 568, 569,
 412, 413, 426, 427, 428, 429, 430, 431, 444, 445, 446, 447, 448, 449, 462, 463, 464, 465, 466, 467,
 480, 481, 482, 483, 484, 485, 498, 499, 500, 501, 502, 503, 516, 517, 518, 519, 520, 521, 534, 535,
 536, 537, 538, 539, 552, 553, 554, 555, 556, 557, 570, 571, 572, 573, 574, 575},

{  0,   1,   2,   3,   6,   7,   8,   9,  12,  13,  14,  15,   4,   5,  18,  19,  10,  11,  24,  25,
  16,  17,  30,  31,  20,  21,  22,  23,  26,  27,  28,  29,  32,  33,  34,  35,  36,  37,  38,  39,
  42,  43,  44,  45,  48,  49,  50,  51,  40,  41,  54,  55,  56,  57,  46,  47,  60,  61,  62,  63,
  52,  53,  66,  67,  68,  69,  58,  59,  72,  73,  74,  75,  64,  65,  78,  79,  80,  81,  70,  71,
  84,  85,  86,  87,  76,  77,  90,  91,  92,  93,  94,  95, 108, 109,  82,  83,  96,  97,  98,  99,
 100, 101, 114, 115,  88,  89, 102, 103, 104, 105, 106, 107, 120, 121, 110, 111, 112, 113, 126, 127,
 128, 129, 130, 131, 144, 145, 116, 117, 118, 119, 132, 133, 134, 135, 136, 137, 150, 151, 122, 123,
 124, 125, 138, 139, 140, 141, 142, 143, 156, 157, 146, 147, 148, 149, 162, 163, 164, 165, 166, 167,
 180, 181, 182, 183, 152, 153, 154, 155, 168, 169, 170, 171, 172, 173, 186, 187, 188, 189, 158, 159,
 160, 161, 174, 175, 176, 177, 178, 179, 192, 193, 194, 195, 184, 185, 198, 199, 200, 201, 202, 203,
 216, 217, 218, 219, 220, 221, 234, 235, 190, 191, 204, 205, 206, 207, 208, 209, 222, 223, 224, 225,
 226, 227, 240, 241, 196, 197, 210, 211, 212, 213, 214, 215, 228, 229, 230, 231, 232, 233, 246, 247,
 236, 237, 238, 239, 252, 253, 254, 255, 256, 257, 270, 271, 272, 273, 274, 275, 288, 289, 290, 291,
 242, 243, 244, 245, 258, 259, 260, 261, 262, 263, 276, 277, 278, 279, 280, 281, 294, 295, 296, 297,
 248, 249, 250, 251, 264, 265, 266, 267, 268, 269, 282, 283, 284, 285, 286, 287, 300, 301, 302, 303,
 292, 293, 306, 307, 308, 309, 310, 311, 324, 325, 326, 327, 328, 329, 342, 343, 344, 345, 346, 347,
 360, 361, 362, 363, 364, 365, 298, 299, 312, 313, 314, 315, 316, 317, 330, 331, 332, 333, 334, 335,
 348, 349, 350, 351, 352, 353, 366, 367, 368, 369, 370, 371, 304, 305, 318, 319, 320, 321, 322, 323,
 336, 337, 338, 339, 340, 341, 354, 355, 356, 357, 358, 359, 372, 373, 374, 375, 376, 377, 378, 379,
 380, 381, 382, 383, 396, 397, 398, 399, 400, 401, 414, 415, 416, 417, 418, 419, 432, 433, 434, 435,
 436, 437, 450, 451, 452, 453, 454, 455, 468, 469, 470, 471, 472, 473, 486, 487, 488, 489, 490, 491,
 504, 505, 506, 507, 508, 509, 522, 523, 524, 525, 526, 527, 540, 541, 542, 543, 544, 545, 558, 559,
 560, 561, 562, 563, 384, 385, 386, 387, 388, 389, 402, 403, 404, 405, 406, 407, 420, 421, 422, 423,
 424, 425, 438, 439, 440, 441, 442, 443, 456, 457, 458, 459, 460, 461, 474, 475, 476, 477, 478, 479,
 492, 493, 494, 495, 496, 497, 510, 511, 512, 513, 514, 515, 528, 529, 530, 531, 532, 533, 546, 547,
 548, 549, 550, 551, 564, 565, 566, 567, 568, 569, 390, 391, 392, 393, 394, 395, 408, 409, 410, 411,
 412, 413, 426, 427, 428, 429, 430, 431, 444, 445, 446, 447, 448, 449, 462, 463, 464, 465, 466, 467,
 480, 481, 482, 483, 484, 485, 498, 499, 500, 501, 502, 503, 516, 517, 518, 519, 520, 521, 534, 535,
 536, 537, 538, 539, 552, 553, 554, 555, 556, 557, 570, 571, 572, 573, 574, 575},

{  0,   1,   2,   3,   6,   7,   8,   9,  12,  13,  14,  15,   4,   5,  18,  19,  10,  11,  24,  25,
  16,  17,  30,  31,  20,  21,  22,  23,  26,  27,  28,  29,  32,  33,  34,  35,  36,  37,  38,  39,
  42,  43,  44,  45,  48,  49,  50,  51,  40,  41,  54,  55,  56,  57,  46,  47,  60,  61,  62,  63,
  52,  53,  66,  67,  68,  69,  58,  59,  72,  73,  74,  75,  76,  77,  64,  65,  78,  79,  80,  81,
  82,  83,  70,  71,  84,  85,  86,  87,  88,  89,  90,  91,  92,  93,  94,  95, 108, 109, 110, 111,
 112, 113,  96,  97,  98,  99, 100, 101, 114, 115, 116, 117, 118, 119, 102, 103, 104, 105, 106, 107,
 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 144, 145, 146, 147, 148, 149, 162, 163,
 164, 165, 132, 133, 134, 135, 136, 137, 150, 151, 152, 153, 154, 155, 168, 169, 170, 171, 138, 139,
 140, 141, 142, 143, 156, 157, 158, 159, 160, 161, 174, 175, 176, 177, 166, 167, 180, 181, 182, 183,
 184, 185, 198, 199, 200, 201, 202, 203, 216, 217, 218, 219, 220, 221, 172, 173, 186, 187, 188, 189,
 190, 191, 204, 205, 206, 207, 208, 209, 222, 223, 224, 225, 226, 227, 178, 179, 192, 193, 194, 195,
 196, 197, 210, 211, 212, 213, 214, 215, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
 252, 253, 254, 255, 256, 257, 270, 271, 272, 273, 274, 275, 288, 289, 290, 291, 292, 293, 306, 307,
 240, 241, 242, 243, 244, 245, 258, 259, 260, 261, 262, 263, 276, 277, 278, 279, 280, 281, 294, 295,
 296, 297, 298, 299, 312, 313, 246, 247, 248, 249, 250, 251, 264, 265, 266, 267, 268, 269, 282, 283,
 284, 285, 286, 287, 300, 301, 302, 303, 304, 305, 318, 319, 308, 309, 310, 311, 324, 325, 326, 327,
 328, 329, 342, 343, 344, 345, 346, 347, 360, 361, 362, 363, 364, 365, 378, 379, 380, 381, 382, 383,
 396, 397, 398, 399, 400, 401, 314, 315, 316, 317, 330, 331, 332, 333, 334, 335, 348, 349, 350, 351,
 352, 353, 366, 367, 368, 369, 370, 371, 384, 385, 386, 387, 388, 389, 402, 403, 404, 405, 406, 407,
 320, 321, 322, 323, 336, 337, 338, 339, 340, 341, 354, 355, 356, 357, 358, 359, 372, 373, 374, 375,
 376, 377, 390, 391, 392, 393, 394, 395, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419,
 432, 433, 434, 435, 436, 437, 450, 451, 452, 453, 454, 455, 468, 469, 470, 471, 472, 473, 486, 487,
 488, 489, 490, 491, 504, 505, 506, 507, 508, 509, 522, 523, 524, 525, 526, 527, 420, 421, 422, 423,
 424, 425, 438, 439, 440, 441, 442, 443, 456, 457, 458, 459, 460, 461, 474, 475, 476, 477, 478, 479,
 492, 493, 494, 495, 496, 497, 510, 511, 512, 513, 514, 515, 528, 529, 530, 531, 532, 533, 426, 427,
 428, 429, 430, 431, 444, 445, 446, 447, 448, 449, 462, 463, 464, 465, 466, 467, 480, 481, 482, 483,
 484, 485, 498, 499, 500, 501, 502, 503, 516, 517, 518, 519, 520, 521, 534, 535, 536, 537, 538, 539,
 540, 541, 542, 543, 544, 545, 558, 559, 560, 561, 562, 563, 546, 547, 548, 549, 550, 551, 564, 565,
 566, 567, 568, 569, 552, 553, 554, 555, 556, 557, 570, 571, 572, 573, 574, 575}
}};

//
// Antialiasing coefficients
//

static const F32 Ca[8] =
{
   -0.5144957554270F, -0.4717319685650F, -0.3133774542040F,
   -0.1819131996110F, -0.0945741925262F, -0.0409655828852F,
   -0.0141985685725F,-0.00369997467375F
};

static const F32 Cs[8] =
{
   0.857492925712F, 0.881741997318F, 0.949628649103F,
   0.983314592492F, 0.995517816065F, 0.999160558175F,
   0.999899195243F, 0.999993155067F
};

//
// Bit rate in bits/second for [MPEG version][value]
//

static const S32 bit_rate[2][15] =
{
   { 0L,8000L,16000L,24000L,32000L,40000L,48000L,56000L,64000L,80000L,96000L,112000L,128000L,144000L,160000L         }
   ,
   { 0L,32000L,40000L,48000L,56000L,64000L,80000L,96000L,112000L,128000L,160000L,192000L,224000L,256000L,320000L     }
};

//
// Sample rate in samples/second for [MPEG25][MPEG version][value]
//

static const S32 sample_rate[2][2][4] =
{{
   { 22050L,24000L,16000L,22050L },
   { 44100L,48000L,32000L,44100L }
},
{
   { 11025L,12000L, 8000L,11025L },
   { 44100L,48000L,32000L,44100L }
}};


static const F32
#if defined(IS_WIN32) || defined(IS_XBOX) || defined(IS_XENON)
__declspec(align(32))
#else
#if defined(IS_PS2) || defined(IS_PSP) || defined(IS_PS3) || defined(IS_3DS)
__attribute__ ((aligned (32)))
#endif
#endif
t_dewindow[17][32] =
{{
 0.000000000f * 16383.5f,-0.000442505f * 16383.5f, 0.003250122f * 16383.5f,-0.007003784f * 16383.5f,0.031082153f * 16383.5f,-0.078628540f * 16383.5f, 0.100311279f * 16383.5f,-0.572036743f * 16383.5f,
 1.144989014f * 16383.5f, 0.572036743f * 16383.5f, 0.100311279f * 16383.5f, 0.078628540f * 16383.5f,0.031082153f * 16383.5f, 0.007003784f * 16383.5f, 0.003250122f * 16383.5f, 0.000442505f * 16383.5f,
 0.000000000f * 16383.5f,-0.000442505f * 16383.5f, 0.003250122f * 16383.5f,-0.007003784f * 16383.5f,0.031082153f * 16383.5f,-0.078628540f * 16383.5f, 0.100311279f * 16383.5f,-0.572036743f * 16383.5f,
 1.144989014f * 16383.5f, 0.572036743f * 16383.5f, 0.100311279f * 16383.5f, 0.078628540f * 16383.5f,0.031082153f * 16383.5f, 0.007003784f * 16383.5f, 0.003250122f * 16383.5f, 0.000442505f * 16383.5f,
},{
-0.000015259f * 16383.5f,-0.000473022f * 16383.5f, 0.003326416f * 16383.5f,-0.007919312f * 16383.5f,0.030517578f * 16383.5f,-0.084182739f * 16383.5f, 0.090927124f * 16383.5f,-0.600219727f * 16383.5f,
 1.144287109f * 16383.5f, 0.543823242f * 16383.5f, 0.108856201f * 16383.5f, 0.073059082f * 16383.5f,0.031478882f * 16383.5f, 0.006118774f * 16383.5f, 0.003173828f * 16383.5f, 0.000396729f * 16383.5f,
-0.000015259f * 16383.5f,-0.000473022f * 16383.5f, 0.003326416f * 16383.5f,-0.007919312f * 16383.5f,0.030517578f * 16383.5f,-0.084182739f * 16383.5f, 0.090927124f * 16383.5f,-0.600219727f * 16383.5f,
 1.144287109f * 16383.5f, 0.543823242f * 16383.5f, 0.108856201f * 16383.5f, 0.073059082f * 16383.5f,0.031478882f * 16383.5f, 0.006118774f * 16383.5f, 0.003173828f * 16383.5f, 0.000396729f * 16383.5f,
},{
-0.000015259f * 16383.5f,-0.000534058f * 16383.5f, 0.003387451f * 16383.5f,-0.008865356f * 16383.5f,0.029785156f * 16383.5f,-0.089706421f * 16383.5f, 0.080688477f * 16383.5f,-0.628295898f * 16383.5f,
 1.142211914f * 16383.5f, 0.515609741f * 16383.5f, 0.116577148f * 16383.5f, 0.067520142f * 16383.5f,0.031738281f * 16383.5f, 0.005294800f * 16383.5f, 0.003082275f * 16383.5f, 0.000366211f * 16383.5f,
-0.000015259f * 16383.5f,-0.000534058f * 16383.5f, 0.003387451f * 16383.5f,-0.008865356f * 16383.5f,0.029785156f * 16383.5f,-0.089706421f * 16383.5f, 0.080688477f * 16383.5f,-0.628295898f * 16383.5f,
 1.142211914f * 16383.5f, 0.515609741f * 16383.5f, 0.116577148f * 16383.5f, 0.067520142f * 16383.5f,0.031738281f * 16383.5f, 0.005294800f * 16383.5f, 0.003082275f * 16383.5f, 0.000366211f * 16383.5f,
},{
-0.000015259f * 16383.5f,-0.000579834f * 16383.5f, 0.003433228f * 16383.5f,-0.009841919f * 16383.5f,0.028884888f * 16383.5f,-0.095169067f * 16383.5f, 0.069595337f * 16383.5f,-0.656219482f * 16383.5f,
 1.138763428f * 16383.5f, 0.487472534f * 16383.5f, 0.123474121f * 16383.5f, 0.061996460f * 16383.5f,0.031845093f * 16383.5f, 0.004486084f * 16383.5f, 0.002990723f * 16383.5f, 0.000320435f * 16383.5f,
-0.000015259f * 16383.5f,-0.000579834f * 16383.5f, 0.003433228f * 16383.5f,-0.009841919f * 16383.5f,0.028884888f * 16383.5f,-0.095169067f * 16383.5f, 0.069595337f * 16383.5f,-0.656219482f * 16383.5f,
 1.138763428f * 16383.5f, 0.487472534f * 16383.5f, 0.123474121f * 16383.5f, 0.061996460f * 16383.5f,0.031845093f * 16383.5f, 0.004486084f * 16383.5f, 0.002990723f * 16383.5f, 0.000320435f * 16383.5f,
},{
-0.000015259f * 16383.5f,-0.000625610f * 16383.5f, 0.003463745f * 16383.5f,-0.010848999f * 16383.5f,0.027801514f * 16383.5f,-0.100540161f * 16383.5f, 0.057617187f * 16383.5f,-0.683914185f * 16383.5f,
 1.133926392f * 16383.5f, 0.459472656f * 16383.5f, 0.129577637f * 16383.5f, 0.056533813f * 16383.5f,0.031814575f * 16383.5f, 0.003723145f * 16383.5f, 0.002899170f * 16383.5f, 0.000289917f * 16383.5f,
-0.000015259f * 16383.5f,-0.000625610f * 16383.5f, 0.003463745f * 16383.5f,-0.010848999f * 16383.5f,0.027801514f * 16383.5f,-0.100540161f * 16383.5f, 0.057617187f * 16383.5f,-0.683914185f * 16383.5f,
 1.133926392f * 16383.5f, 0.459472656f * 16383.5f, 0.129577637f * 16383.5f, 0.056533813f * 16383.5f,0.031814575f * 16383.5f, 0.003723145f * 16383.5f, 0.002899170f * 16383.5f, 0.000289917f * 16383.5f,
},{
-0.000015259f * 16383.5f,-0.000686646f * 16383.5f, 0.003479004f * 16383.5f,-0.011886597f * 16383.5f,0.026535034f * 16383.5f,-0.105819702f * 16383.5f, 0.044784546f * 16383.5f,-0.711318970f * 16383.5f,
 1.127746582f * 16383.5f, 0.431655884f * 16383.5f, 0.134887695f * 16383.5f, 0.051132202f * 16383.5f,0.031661987f * 16383.5f, 0.003005981f * 16383.5f, 0.002792358f * 16383.5f, 0.000259399f * 16383.5f,
-0.000015259f * 16383.5f,-0.000686646f * 16383.5f, 0.003479004f * 16383.5f,-0.011886597f * 16383.5f,0.026535034f * 16383.5f,-0.105819702f * 16383.5f, 0.044784546f * 16383.5f,-0.711318970f * 16383.5f,
 1.127746582f * 16383.5f, 0.431655884f * 16383.5f, 0.134887695f * 16383.5f, 0.051132202f * 16383.5f,0.031661987f * 16383.5f, 0.003005981f * 16383.5f, 0.002792358f * 16383.5f, 0.000259399f * 16383.5f,
},{
-0.000015259f * 16383.5f,-0.000747681f * 16383.5f, 0.003479004f * 16383.5f,-0.012939453f * 16383.5f,0.025085449f * 16383.5f,-0.110946655f * 16383.5f, 0.031082153f * 16383.5f,-0.738372803f * 16383.5f,
 1.120223999f * 16383.5f, 0.404083252f * 16383.5f, 0.139450073f * 16383.5f, 0.045837402f * 16383.5f,0.031387329f * 16383.5f, 0.002334595f * 16383.5f, 0.002685547f * 16383.5f, 0.000244141f * 16383.5f,
-0.000015259f * 16383.5f,-0.000747681f * 16383.5f, 0.003479004f * 16383.5f,-0.012939453f * 16383.5f,0.025085449f * 16383.5f,-0.110946655f * 16383.5f, 0.031082153f * 16383.5f,-0.738372803f * 16383.5f,
 1.120223999f * 16383.5f, 0.404083252f * 16383.5f, 0.139450073f * 16383.5f, 0.045837402f * 16383.5f,0.031387329f * 16383.5f, 0.002334595f * 16383.5f, 0.002685547f * 16383.5f, 0.000244141f * 16383.5f,
},{
-0.000030518f * 16383.5f,-0.000808716f * 16383.5f, 0.003463745f * 16383.5f,-0.014022827f * 16383.5f,0.023422241f * 16383.5f,-0.115921021f * 16383.5f, 0.016510010f * 16383.5f,-0.765029907f * 16383.5f,
 1.111373901f * 16383.5f, 0.376800537f * 16383.5f, 0.143264771f * 16383.5f, 0.040634155f * 16383.5f,0.031005859f * 16383.5f, 0.001693726f * 16383.5f, 0.002578735f * 16383.5f, 0.000213623f * 16383.5f,
-0.000030518f * 16383.5f,-0.000808716f * 16383.5f, 0.003463745f * 16383.5f,-0.014022827f * 16383.5f,0.023422241f * 16383.5f,-0.115921021f * 16383.5f, 0.016510010f * 16383.5f,-0.765029907f * 16383.5f,
 1.111373901f * 16383.5f, 0.376800537f * 16383.5f, 0.143264771f * 16383.5f, 0.040634155f * 16383.5f,0.031005859f * 16383.5f, 0.001693726f * 16383.5f, 0.002578735f * 16383.5f, 0.000213623f * 16383.5f,
},{
-0.000030518f * 16383.5f,-0.000885010f * 16383.5f, 0.003417969f * 16383.5f,-0.015121460f * 16383.5f,0.021575928f * 16383.5f,-0.120697021f * 16383.5f, 0.001068115f * 16383.5f,-0.791213989f * 16383.5f,
 1.101211548f * 16383.5f, 0.349868774f * 16383.5f, 0.146362305f * 16383.5f, 0.035552979f * 16383.5f,0.030532837f * 16383.5f, 0.001098633f * 16383.5f, 0.002456665f * 16383.5f, 0.000198364f * 16383.5f,
-0.000030518f * 16383.5f,-0.000885010f * 16383.5f, 0.003417969f * 16383.5f,-0.015121460f * 16383.5f,0.021575928f * 16383.5f,-0.120697021f * 16383.5f, 0.001068115f * 16383.5f,-0.791213989f * 16383.5f,
 1.101211548f * 16383.5f, 0.349868774f * 16383.5f, 0.146362305f * 16383.5f, 0.035552979f * 16383.5f,0.030532837f * 16383.5f, 0.001098633f * 16383.5f, 0.002456665f * 16383.5f, 0.000198364f * 16383.5f,
},{
-0.000030518f * 16383.5f,-0.000961304f * 16383.5f, 0.003372192f * 16383.5f,-0.016235352f * 16383.5f,0.019531250f * 16383.5f,-0.125259399f * 16383.5f,-0.015228271f * 16383.5f,-0.816864014f * 16383.5f,
 1.089782715f * 16383.5f, 0.323318481f * 16383.5f, 0.148773193f * 16383.5f, 0.030609131f * 16383.5f,0.029937744f * 16383.5f, 0.000549316f * 16383.5f, 0.002349854f * 16383.5f, 0.000167847f * 16383.5f,
-0.000030518f * 16383.5f,-0.000961304f * 16383.5f, 0.003372192f * 16383.5f,-0.016235352f * 16383.5f,0.019531250f * 16383.5f,-0.125259399f * 16383.5f,-0.015228271f * 16383.5f,-0.816864014f * 16383.5f,
 1.089782715f * 16383.5f, 0.323318481f * 16383.5f, 0.148773193f * 16383.5f, 0.030609131f * 16383.5f,0.029937744f * 16383.5f, 0.000549316f * 16383.5f, 0.002349854f * 16383.5f, 0.000167847f * 16383.5f,
},{
-0.000030518f * 16383.5f,-0.001037598f * 16383.5f, 0.003280640f * 16383.5f,-0.017349243f * 16383.5f,0.017257690f * 16383.5f,-0.129562378f * 16383.5f,-0.032379150f * 16383.5f,-0.841949463f * 16383.5f,
 1.077117920f * 16383.5f, 0.297210693f * 16383.5f, 0.150497437f * 16383.5f, 0.025817871f * 16383.5f,0.029281616f * 16383.5f, 0.000030518f * 16383.5f, 0.002243042f * 16383.5f, 0.000152588f * 16383.5f,
-0.000030518f * 16383.5f,-0.001037598f * 16383.5f, 0.003280640f * 16383.5f,-0.017349243f * 16383.5f,0.017257690f * 16383.5f,-0.129562378f * 16383.5f,-0.032379150f * 16383.5f,-0.841949463f * 16383.5f,
 1.077117920f * 16383.5f, 0.297210693f * 16383.5f, 0.150497437f * 16383.5f, 0.025817871f * 16383.5f,0.029281616f * 16383.5f, 0.000030518f * 16383.5f, 0.002243042f * 16383.5f, 0.000152588f * 16383.5f,
},{
-0.000045776f * 16383.5f,-0.001113892f * 16383.5f, 0.003173828f * 16383.5f,-0.018463135f * 16383.5f,0.014801025f * 16383.5f,-0.133590698f * 16383.5f,-0.050354004f * 16383.5f,-0.866363525f * 16383.5f,
 1.063217163f * 16383.5f, 0.271591187f * 16383.5f, 0.151596069f * 16383.5f, 0.021179199f * 16383.5f,0.028533936f * 16383.5f,-0.000442505f * 16383.5f, 0.002120972f * 16383.5f, 0.000137329f * 16383.5f,
-0.000045776f * 16383.5f,-0.001113892f * 16383.5f, 0.003173828f * 16383.5f,-0.018463135f * 16383.5f,0.014801025f * 16383.5f,-0.133590698f * 16383.5f,-0.050354004f * 16383.5f,-0.866363525f * 16383.5f,
 1.063217163f * 16383.5f, 0.271591187f * 16383.5f, 0.151596069f * 16383.5f, 0.021179199f * 16383.5f,0.028533936f * 16383.5f,-0.000442505f * 16383.5f, 0.002120972f * 16383.5f, 0.000137329f * 16383.5f,
},{
-0.000045776f * 16383.5f,-0.001205444f * 16383.5f, 0.003051758f * 16383.5f,-0.019577026f * 16383.5f,0.012115479f * 16383.5f,-0.137298584f * 16383.5f,-0.069168091f * 16383.5f,-0.890090942f * 16383.5f,
 1.048156738f * 16383.5f, 0.246505737f * 16383.5f, 0.152069092f * 16383.5f, 0.016708374f * 16383.5f,0.027725220f * 16383.5f,-0.000869751f * 16383.5f, 0.002014160f * 16383.5f, 0.000122070f * 16383.5f,
-0.000045776f * 16383.5f,-0.001205444f * 16383.5f, 0.003051758f * 16383.5f,-0.019577026f * 16383.5f,0.012115479f * 16383.5f,-0.137298584f * 16383.5f,-0.069168091f * 16383.5f,-0.890090942f * 16383.5f,
 1.048156738f * 16383.5f, 0.246505737f * 16383.5f, 0.152069092f * 16383.5f, 0.016708374f * 16383.5f,0.027725220f * 16383.5f,-0.000869751f * 16383.5f, 0.002014160f * 16383.5f, 0.000122070f * 16383.5f,
},{
-0.000061035f * 16383.5f,-0.001296997f * 16383.5f, 0.002883911f * 16383.5f,-0.020690918f * 16383.5f,0.009231567f * 16383.5f,-0.140670776f * 16383.5f,-0.088775635f * 16383.5f,-0.913055420f * 16383.5f,
 1.031936646f * 16383.5f, 0.221984863f * 16383.5f, 0.151962280f * 16383.5f, 0.012420654f * 16383.5f,0.026840210f * 16383.5f,-0.001266479f * 16383.5f, 0.001907349f * 16383.5f, 0.000106812f * 16383.5f,
-0.000061035f * 16383.5f,-0.001296997f * 16383.5f, 0.002883911f * 16383.5f,-0.020690918f * 16383.5f,0.009231567f * 16383.5f,-0.140670776f * 16383.5f,-0.088775635f * 16383.5f,-0.913055420f * 16383.5f,
 1.031936646f * 16383.5f, 0.221984863f * 16383.5f, 0.151962280f * 16383.5f, 0.012420654f * 16383.5f,0.026840210f * 16383.5f,-0.001266479f * 16383.5f, 0.001907349f * 16383.5f, 0.000106812f * 16383.5f,
},{
-0.000061035f * 16383.5f,-0.001388550f * 16383.5f, 0.002700806f * 16383.5f,-0.021789551f * 16383.5f,0.006134033f * 16383.5f,-0.143676758f * 16383.5f,-0.109161377f * 16383.5f,-0.935195923f * 16383.5f,
 1.014617920f * 16383.5f, 0.198059082f * 16383.5f, 0.151306152f * 16383.5f, 0.008316040f * 16383.5f,0.025909424f * 16383.5f,-0.001617432f * 16383.5f, 0.001785278f * 16383.5f, 0.000106812f * 16383.5f,
-0.000061035f * 16383.5f,-0.001388550f * 16383.5f, 0.002700806f * 16383.5f,-0.021789551f * 16383.5f,0.006134033f * 16383.5f,-0.143676758f * 16383.5f,-0.109161377f * 16383.5f,-0.935195923f * 16383.5f,
 1.014617920f * 16383.5f, 0.198059082f * 16383.5f, 0.151306152f * 16383.5f, 0.008316040f * 16383.5f,0.025909424f * 16383.5f,-0.001617432f * 16383.5f, 0.001785278f * 16383.5f, 0.000106812f * 16383.5f,
},{
-0.000076294f * 16383.5f,-0.001480103f * 16383.5f, 0.002487183f * 16383.5f,-0.022857666f * 16383.5f,0.002822876f * 16383.5f,-0.146255493f * 16383.5f,-0.130310059f * 16383.5f,-0.956481934f * 16383.5f,
 0.996246338f * 16383.5f, 0.174789429f * 16383.5f, 0.150115967f * 16383.5f, 0.004394531f * 16383.5f,0.024932861f * 16383.5f,-0.001937866f * 16383.5f, 0.001693726f * 16383.5f, 0.000091553f * 16383.5f,
-0.000076294f * 16383.5f,-0.001480103f * 16383.5f, 0.002487183f * 16383.5f,-0.022857666f * 16383.5f,0.002822876f * 16383.5f,-0.146255493f * 16383.5f,-0.130310059f * 16383.5f,-0.956481934f * 16383.5f,
 0.996246338f * 16383.5f, 0.174789429f * 16383.5f, 0.150115967f * 16383.5f, 0.004394531f * 16383.5f,0.024932861f * 16383.5f,-0.001937866f * 16383.5f, 0.001693726f * 16383.5f, 0.000091553f * 16383.5f,
},{
-0.000076294f * 16383.5f,-0.001586914f * 16383.5f, 0.002227783f * 16383.5f,-0.023910522f * 16383.5f,-0.000686646f * 16383.5f,-0.148422241f * 16383.5f,-0.152206421f * 16383.5f,-0.976852417f * 16383.5f,
 0.976852417f * 16383.5f, 0.152206421f * 16383.5f, 0.148422241f * 16383.5f, 0.000686646f * 16383.5f, 0.023910522f * 16383.5f,-0.002227783f * 16383.5f, 0.001586914f * 16383.5f, 0.000076294f * 16383.5f,
-0.000076294f * 16383.5f,-0.001586914f * 16383.5f, 0.002227783f * 16383.5f,-0.023910522f * 16383.5f,-0.000686646f * 16383.5f,-0.148422241f * 16383.5f,-0.152206421f * 16383.5f,-0.976852417f * 16383.5f,
 0.976852417f * 16383.5f, 0.152206421f * 16383.5f, 0.148422241f * 16383.5f, 0.000686646f * 16383.5f, 0.023910522f * 16383.5f,-0.002227783f * 16383.5f, 0.001586914f * 16383.5f, 0.000076294f * 16383.5f,
} };


static const F32 b[32] =
{
 0.000000000f,
 1.997590912f, 1.990369453f, 1.978353019f,
 1.961570560f, 1.940062506f, 1.913880671f,
 1.883088130f, 1.847759065f, 1.807978586f,
 1.763842529f, 1.715457220f, 1.662939225f,
 1.606415063f, 1.546020907f, 1.481902251f,
 1.414213562f, 1.343117910f, 1.268786568f,
 1.191398609f, 1.111140466f, 1.028205488f,
 0.942793474f, 0.855110187f, 0.765366865f,
 0.673779707f, 0.580569355f, 0.485960360f,
 0.390180644f, 0.293460949f, 0.196034281f,
 0.098135349f
};


// these int tables are really floats, but we use
// ints to get the exact values compiled in (C++ sucks)

//
// Table of 2 to the nth power, where n is successive multiples of -0.5
//

static const S32 lfac[ 256 ] =
{
  0x3F800000, 0x3F3504F3, 0x3F000000, 0x3EB504F3,
  0x3E800000, 0x3E3504F3, 0x3E000000, 0x3DB504F3,
  0x3D800000, 0x3D3504F3, 0x3D000000, 0x3CB504F3,
  0x3C800000, 0x3C3504F3, 0x3C000000, 0x3BB504F3,
  0x3B800000, 0x3B3504F3, 0x3B000000, 0x3AB504F3,
  0x3A800000, 0x3A3504F3, 0x3A000000, 0x39B504F3,
  0x39800000, 0x393504F3, 0x39000000, 0x38B504F3,
  0x38800000, 0x383504F3, 0x38000000, 0x37B504F3,
  0x37800000, 0x373504F3, 0x37000000, 0x36B504F3,
  0x36800000, 0x363504F3, 0x36000000, 0x35B504F3,
  0x35800000, 0x353504F3, 0x35000000, 0x34B504F3,
  0x34800000, 0x343504F3, 0x34000000, 0x33B504F3,
  0x33800000, 0x333504F3, 0x33000000, 0x32B504F3,
  0x32800000, 0x323504F3, 0x32000000, 0x31B504F3,
  0x31800000, 0x313504F3, 0x31000000, 0x30B504F3,
  0x30800000, 0x303504F3, 0x30000000, 0x2FB504F3,
  0x2F800000, 0x2F3504F3, 0x2F000000, 0x2EB504F3,
  0x2E800000, 0x2E3504F3, 0x2E000000, 0x2DB504F3,
  0x2D800000, 0x2D3504F3, 0x2D000000, 0x2CB504F3,
  0x2C800000, 0x2C3504F3, 0x2C000000, 0x2BB504F3,
  0x2B800000, 0x2B3504F3, 0x2B000000, 0x2AB504F3,
  0x2A800000, 0x2A3504F3, 0x2A000000, 0x29B504F3,
  0x29800000, 0x293504F3, 0x29000000, 0x28B504F3,
  0x28800000, 0x283504F3, 0x28000000, 0x27B504F3,
  0x27800000, 0x273504F3, 0x27000000, 0x26B504F3,
  0x26800000, 0x263504F3, 0x26000000, 0x25B504F3,
  0x25800000, 0x253504F3, 0x25000000, 0x24B504F3,
  0x24800000, 0x243504F3, 0x24000000, 0x23B504F3,
  0x23800000, 0x233504F3, 0x23000000, 0x22B504F3,
  0x22800000, 0x223504F3, 0x22000000, 0x21B504F3,
  0x21800000, 0x213504F3, 0x21000000, 0x20B504F3,
  0x20800000, 0x203504F3, 0x20000000, 0x1FB504F3,
  0x1F800000, 0x1F3504F3, 0x1F000000, 0x1EB504F3,
  0x1E800000, 0x1E3504F3, 0x1E000000, 0x1DB504F3,
  0x1D800000, 0x1D3504F3, 0x1D000000, 0x1CB504F3,
  0x1C800000, 0x1C3504F3, 0x1C000000, 0x1BB504F3,
  0x1B800000, 0x1B3504F3, 0x1B000000, 0x1AB504F3,
  0x1A800000, 0x1A3504F3, 0x1A000000, 0x19B504F3,
  0x19800000, 0x193504F3, 0x19000000, 0x18B504F3,
  0x18800000, 0x183504F3, 0x18000000, 0x17B504F3,
  0x17800000, 0x173504F3, 0x17000000, 0x16B504F3,
  0x16800000, 0x163504F3, 0x16000000, 0x15B504F3,
  0x15800000, 0x153504F3, 0x15000000, 0x14B504F3,
  0x14800000, 0x143504F3, 0x14000000, 0x13B504F3,
  0x13800000, 0x133504F3, 0x13000000, 0x12B504F3,
  0x12800000, 0x123504F3, 0x12000000, 0x11B504F3,
  0x11800000, 0x113504F3, 0x11000000, 0x10B504F3,
  0x10800000, 0x103504F3, 0x10000000, 0xFB504F3,
  0xF800000, 0xF3504F3, 0xF000000, 0xEB504F3,
  0xE800000, 0xE3504F3, 0xE000000, 0xDB504F3,
  0xD800000, 0xD3504F3, 0xD000000, 0xCB504F3,
  0xC800000, 0xC3504F3, 0xC000000, 0xBB504F3,
  0xB800000, 0xB3504F3, 0xB000000, 0xAB504F3,
  0xA800000, 0xA3504F3, 0xA000000, 0x9B504F3,
  0x9800000, 0x93504F3, 0x9000000, 0x8B504F3,
  0x8800000, 0x83504F3, 0x8000000, 0x7B504F3,
  0x7800000, 0x73504F3, 0x7000000, 0x6B504F3,
  0x6800000, 0x63504F3, 0x6000000, 0x5B504F3,
  0x5800000, 0x53504F3, 0x5000000, 0x4B504F3,
  0x4800000, 0x43504F3, 0x4000000, 0x3B504F3,
  0x3800000, 0x33504F3, 0x3000000, 0x2B504F3,
  0x2800000, 0x23504F3, 0x2000000, 0x1B504F3,
  0x1800000, 0x13504F3, 0x1000000, 0xB504F3,
  0x800000, 0x0, 0x0, 0x0,
};

//
// Table of 2 to the nth power, where n is successive multiples of -2.0
//

static const S32 sfac[ 256 ] =
{
  0x3F800000, 0x3E800000, 0x3D800000, 0x3C800000,
  0x3B800000, 0x3A800000, 0x39800000, 0x38800000,
  0x37800000, 0x36800000, 0x35800000, 0x34800000,
  0x33800000, 0x32800000, 0x31800000, 0x30800000,
  0x2F800000, 0x2E800000, 0x2D800000, 0x2C800000,
  0x2B800000, 0x2A800000, 0x29800000, 0x28800000,
  0x27800000, 0x26800000, 0x25800000, 0x24800000,
  0x23800000, 0x22800000, 0x21800000, 0x20800000,
  0x1F800000, 0x1E800000, 0x1D800000, 0x1C800000,
  0x1B800000, 0x1A800000, 0x19800000, 0x18800000,
  0x17800000, 0x16800000, 0x15800000, 0x14800000,
  0x13800000, 0x12800000, 0x11800000, 0x10800000,
  0xF800000, 0xE800000, 0xD800000, 0xC800000,
  0xB800000, 0xA800000, 0x9800000, 0x8800000,
  0x7800000, 0x6800000, 0x5800000, 0x4800000,
  0x3800000, 0x2800000, 0x1800000, 0x800000,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0,
};


// cuberoot tables...
static const S32 cr4_64[ 64 ] =
{
  0x0, 0x3F800000, 0x40214518, 0x408A74BA,
  0x40CB2FF5, 0x4108CC4F, 0x412E718E, 0x41563F90,
  0x41800000, 0x4195C41B, 0x41AC5AD3, 0x41C3B5D3,
  0x41DBC8FF, 0x41F489EF, 0x4206F7CD, 0x4213F904,
  0x42214518, 0x422ED8DF, 0x423CB181, 0x424ACC6C,
  0x42592746, 0x4267BFE8, 0x42769458, 0x4282D161,
  0x428A74BA, 0x4292336D, 0x429A0CBF, 0x42A20000,
  0x42AA0C8A, 0x42B231C3, 0x42BA6F17, 0x42C2C3FE,
  0x42CB2FF5, 0x42D3B280, 0x42DC4B2A, 0x42E4F982,
  0x42EDBD20, 0x42F6959C, 0x42FF8298, 0x430441DB,
  0x4308CC4F, 0x430D607D, 0x4311FE3D, 0x4316A568,
  0x431B55D8, 0x43200F69, 0x4324D1F9, 0x43299D65,
  0x432E718E, 0x43334E55, 0x4338339A, 0x433D2142,
  0x43421730, 0x43471549, 0x434C1B72, 0x43512992,
  0x43563F90, 0x435B5D54, 0x436082C7, 0x4365AFD1,
  0x436AE45E, 0x43702057, 0x437563A8, 0x437AAE3C,
};

static const S32 cr4_b32[ 65 ] =
{
  0x0, 0x42CB2FF5, 0x43800000, 0x43DBC8FF,
  0x44214518, 0x44592746, 0x448A74BA, 0x44AA0C8A,
  0x44CB2FF5, 0x44EDBD20, 0x4508CC4F, 0x451B55D8,
  0x452E718E, 0x45421730, 0x45563F90, 0x456AE45E,
  0x45800000, 0x458AC6BA, 0x4595C41B, 0x45A0F618,
  0x45AC5AD3, 0x45B7F097, 0x45C3B5D3, 0x45CFA913,
  0x45DBC8FF, 0x45E81456, 0x45F489EF, 0x46009459,
  0x4606F7CD, 0x460D6ED7, 0x4613F904, 0x461A95E7,
  0x46214518, 0x46280634, 0x462ED8DF, 0x4635BCBF,
  0x463CB181, 0x4643B6D5, 0x464ACC6C, 0x4651F1FF,
  0x46592746, 0x46606BFE, 0x4667BFE8, 0x466F22C4,
  0x46769458, 0x467E1469, 0x4682D161, 0x46869F96,
  0x468A74BA, 0x468E50B4, 0x4692336D, 0x46961CCE,
  0x469A0CBF, 0x469E032C, 0x46A20000, 0x46A60326,
  0x46AA0C8A, 0x46AE1C1A, 0x46B231C3, 0x46B64D72,
  0x46BA6F17, 0x46BE96A1, 0x46C2C3FE, 0x46C6F720,
  0x46CB2FF5,
};

static const S32 cr4_b128[ 66 ] =
{
  0x0, 0x44214518, 0x44CB2FF5, 0x452E718E,
  0x45800000, 0x45AC5AD3, 0x45DBC8FF, 0x4606F7CD,
  0x46214518, 0x463CB181, 0x46592746, 0x46769458,
  0x468A74BA, 0x469A0CBF, 0x46AA0C8A, 0x46BA6F17,
  0x46CB2FF5, 0x46DC4B2A, 0x46EDBD20, 0x46FF8298,
  0x4708CC4F, 0x4711FE3D, 0x471B55D8, 0x4724D1F9,
  0x472E718E, 0x4738339A, 0x47421730, 0x474C1B72,
  0x47563F90, 0x476082C7, 0x476AE45E, 0x477563A8,
  0x47800000, 0x47855C65, 0x478AC6BA, 0x47903EB7,
  0x4795C41B, 0x479B56A5, 0x47A0F618, 0x47A6A239,
  0x47AC5AD3, 0x47B21FAD, 0x47B7F097, 0x47BDCD5E,
  0x47C3B5D3, 0x47C9A9C8, 0x47CFA913, 0x47D5B388,
  0x47DBC8FF, 0x47E1E950, 0x47E81456, 0x47EE49ED,
  0x47F489EF, 0x47FAD43C, 0x48009459, 0x4803C399,
  0x4806F7CD, 0x480A30E6, 0x480D6ED7, 0x4810B190,
  0x4813F904, 0x48174526, 0x481A95E7, 0x481DEB3C,
  0x48214518, 0x4824A36E,
};

static const S32 recp_32[ 32 ] =
{
  0x0, 0x3CF15674, 0x3D71E00C, 0x3DB5CE14,
  0x3DF2EED1, 0x3E1828AE, 0x3E36FA5E, 0x3E55EC0C,
  0x3E74FD48, 0x3E8A16CC, 0x3E99BE5E, 0x3EA97517,
  0x3EB93ACD, 0x3EC90F50, 0x3ED8F273, 0x3EE8E45D,
  0x3EF8E4B7, 0x3F04799E, 0x3F0C87D2, 0x3F149CF2,
  0x3F1CB8D8, 0x3F24DB7E, 0x3F2D04C8, 0x3F3534A0,
  0x3F3D6AFC, 0x3F45A7CE, 0x3F4DEAF6, 0x3F563470,
  0x3F5E8420, 0x3F66D9FC, 0x3F6F35F4, 0x3F7797F6,
};

static const S32 recp_128[ 128 ] =
{
  0x0, 0x3BFDD791, 0x3C7DE31B, 0x3CBE6912,
  0x3CFDE758, 0x3D1EB1DC, 0x3D3E73F3, 0x3D5E3691,
  0x3D7DF83C, 0x3D8EDE19, 0x3D9EC134, 0x3DAEA49D,
  0x3DBE8854, 0x3DCE6BB0, 0x3DDE5162, 0x3DEE3692,
  0x3DFE1C92, 0x3E070190, 0x3E0EF4F5, 0x3E16E8CA,
  0x3E1EDCC2, 0x3E26D0DD, 0x3E2EC568, 0x3E36BA5C,
  0x3E3EAF73, 0x3E46A540, 0x3E4E9AE3, 0x3E5690DA,
  0x3E5E8709, 0x3E667D31, 0x3E6E73DE, 0x3E766B56,
  0x3E7E62CE, 0x3E832D29, 0x3E8728EB, 0x3E8B24F5,
  0x3E8F2126, 0x3E931D78, 0x3E971A03, 0x3E9B16C1,
  0x3E9F1379, 0x3EA31055, 0x3EA70D61, 0x3EAB0A85,
  0x3EAF07A6, 0x3EB3054E, 0x3EB702BA, 0x3EBB0071,
  0x3EBEFE55, 0x3EC2FC1B, 0x3EC6FA4A, 0x3ECAF879,
  0x3ECEF6C6, 0x3ED2F57C, 0x3ED6F411, 0x3EDAF2BE,
  0x3EDEF1D1, 0x3EE2F0B4, 0x3EE6EFEE, 0x3EEAEF34,
  0x3EEEEE95, 0x3EF2EE53, 0x3EF6EDE7, 0x3EFAEDB4,
  0x3EFEEDC3, 0x3F0176DA, 0x3F037714, 0x3F05773E,
  0x3F077770, 0x3F0977C2, 0x3F0B7828, 0x3F0D788E,
  0x3F0F7920, 0x3F1179CA, 0x3F137A70, 0x3F157B2E,
  0x3F177BE2, 0x3F197CD8, 0x3F1B7DA8, 0x3F1D7EAE,
  0x3F1F7FC0, 0x3F2180DE, 0x3F2381F6, 0x3F258338,
  0x3F2784AA, 0x3F29860A, 0x3F2B8768, 0x3F2D88FA,
  0x3F2F8A96, 0x3F318C46, 0x3F338DD6, 0x3F358FCA,
  0x3F37918E, 0x3F399382, 0x3F3B9578, 0x3F3D976E,
  0x3F3F9994, 0x3F419BD0, 0x3F439E10, 0x3F45A04C,
  0x3F47A2C8, 0x3F49A51E, 0x3F4BA7BC, 0x3F4DAA36,
  0x3F4FACDE, 0x3F51AFA2, 0x3F53B258, 0x3F55B53E,
  0x3F57B82A, 0x3F59BB2A, 0x3F5BBE2A, 0x3F5DC156,
  0x3F5FC45E, 0x3F61C7AE, 0x3F63CAEE, 0x3F65CE32,
  0x3F67D1BE, 0x3F69D53A, 0x3F6BD8C4, 0x3F6DDC70,
  0x3F6FE022, 0x3F71E3DA, 0x3F73E7B0, 0x3F75EB94,
  0x3F77EF86, 0x3F79F38A, 0x3F7BF79C, 0x3F7DFBC4,
};

static const S32 win[ 4 ][ 36 ] =
{
  {
    0x3D32AA3E, 0x3E05A8A8, 0x3E5DA258, 0x3E99F61C,
    0x3EC3EF15, 0x3EEC6A50, 0x3F098C77, 0x3F1BD7CA,
    0x3F2CF37B, 0x3F3CBE35, 0x3F4B1934, 0x3F57E880,
    0x3F631324, 0x3F6C835E, 0x3F7426CB, 0x3F79EE89,
    0x3F7DCF54, 0x3F7FC1A0, 0x3F7FC1A0, 0x3F7DCF55,
    0x3F79EE89, 0x3F7426CC, 0x3F6C835F, 0x3F631325,
    0x3F57E881, 0x3F4B1935, 0x3F3CBE36, 0x3F2CF37C,
    0x3F1BD7CB, 0x3F098C79, 0x3EEC6A53, 0x3EC3EF18,
    0x3E99F61F, 0x3E5DA25E, 0x3E05A8AE, 0x3D32AA56,
  },
  {
    0x3D32AA3E, 0x3E05A8A8, 0x3E5DA258, 0x3E99F61C,
    0x3EC3EF15, 0x3EEC6A50, 0x3F098C77, 0x3F1BD7CA,
    0x3F2CF37B, 0x3F3CBE35, 0x3F4B1934, 0x3F57E880,
    0x3F631324, 0x3F6C835E, 0x3F7426CB, 0x3F79EE89,
    0x3F7DCF54, 0x3F7FC1A0, 0x3F800000, 0x3F800000,
    0x3F800000, 0x3F800000, 0x3F800000, 0x3F800000,
    0x3F7DCF54, 0x3F6C835E, 0x3F4B1934, 0x3F1BD7C9,
    0x3EC3EF13, 0x3E05A8A3, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0,
  },
  {
    0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0,
  },
  {
    0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x3E05A8A9, 0x3EC3EF16,
    0x3F1BD7CA, 0x3F4B1935, 0x3F6C835F, 0x3F7DCF55,
    0x3F800000, 0x3F800000, 0x3F800000, 0x3F800000,
    0x3F800000, 0x3F800000, 0x3F7FC1A0, 0x3F7DCF55,
    0x3F79EE89, 0x3F7426CC, 0x3F6C835F, 0x3F631325,
    0x3F57E881, 0x3F4B1935, 0x3F3CBE36, 0x3F2CF37C,
    0x3F1BD7CB, 0x3F098C79, 0x3EEC6A53, 0x3EC3EF18,
    0x3E99F61F, 0x3E5DA25E, 0x3E05A8AE, 0x3D32AA56,
  },
};



#ifndef MSS_SPU_PROCESS

//############################################################################
//#                                                                          #
//# Init layer-3 specific data                                               #
//#                                                                          #
//############################################################################

S32 L3_init( MSS_ALLOC_TYPE * palloc, MSS_FREE_TYPE * pfree )
{
   //
   // Copy offset dewindows
   //
#if VECTOR_DEWINDOW
   if ( l3free == 0 )
   {
     s_DewindowOff4raw = (F32*)palloc(4*17*32 + 16,0,__FILE__,__LINE__);
     s_DewindowOff8raw = (F32*)palloc(4*17*32 + 16,0,__FILE__,__LINE__);
     s_DewindowOff12raw = (F32*)palloc(4*17*32 + 16,0,__FILE__,__LINE__);
     s_DewindowOff4 = (float*)(((UINTa)s_DewindowOff4raw + 15) & ~0xf) + 1;
     s_DewindowOff8 = (float*)(((UINTa)s_DewindowOff8raw + 15) & ~0xf) + 2;
     s_DewindowOff12 = (float*)(((UINTa)s_DewindowOff12raw + 15) & ~0xf) + 3;

     AIL_memcpy(s_DewindowOff4, t_dewindow, 4*17*32);
     AIL_memcpy(s_DewindowOff8, t_dewindow, 4*17*32);
     AIL_memcpy(s_DewindowOff12, t_dewindow, 4*17*32);

     l3free = pfree;
   }
#endif // VECTOR_DEWINDOW


   //
   // Return success
   //

   return 1;
}

//############################################################################
//#                                                                          #
//# Destroy layer-3 specific data                                            #
//#                                                                          #
//############################################################################

S32 L3_destroy(void)
{
    // Free offset dewindows.
#if VECTOR_DEWINDOW
    if ( l3free )
    {
      l3free(s_DewindowOff12raw,0,__FILE__,__LINE__);
      l3free(s_DewindowOff8raw,0,__FILE__,__LINE__);
      l3free(s_DewindowOff4raw,0,__FILE__,__LINE__);
      l3free = 0;
    }
#endif

   //
   // Return success
   //

   return 1;
}

#endif

typedef F32 xr_type[32][18];
typedef S16 is_type[578];
typedef F32 u_type[2][17][16];

//############################################################################
//#                                                                          #
//# Perform layer 3 scaling and requantization                               #
//#                                                                          #
//############################################################################

static S32 L3_requantize(ASISTREAM *STR, S32 gr, S32 ch, is_type * isptr, xr_type* xrptr)
{
   //
   // Choose correct scalefactor band per block type, and initialize boundary
   //

   S32 sfreq = STR->sampling_frequency + (STR->MPEG1 * 3);

   S32 next_cb_boundary, cb_begin=0, cb_width=0;

   if (STR->window_switching_flag[gr][ch] && (STR->block_type[gr][ch] == 2))
      {
      if (STR->mixed_block_flag[gr][ch])
         {
         //
         // Long or mixed blocks (0,1,3)
         //

         next_cb_boundary = sfBandIndex[sfreq].l[1];
         }
      else
         {
         //
         // Pure short block
         //

         next_cb_boundary = sfBandIndex[sfreq].s[1] * 3;

         cb_width = sfBandIndex[sfreq].s[1];
         cb_begin = 0;
         }
      }
   else
      {
      //
      // Pure long block
      //

      next_cb_boundary = sfBandIndex[sfreq].l[1];
      }

   //
   // Build quantization tables for this granule and channel
   //

   static const S32 pretab[22] = {0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,3,3,3,2,0};

   F32 long_scalar[22];
   F32 short_scalar[3][13];

   F32 common = AIL_pow(2.0f, (0.25f * (STR->global_gain[gr][ch] - 210.0f)));

   S32 cb,group;

   S32 sf_scale = STR->scalefac_scale[gr][ch];

   for (cb=0; cb < 22; cb++)
      {
      S32 n = (1 + sf_scale) * (STR->scalefac[gr][ch].l[cb] + STR->preflag[gr][ch] * pretab[cb]);

      long_scalar[cb] = common * (*(F32*)(void*)&lfac[n]);
      }

   for (group=0; group < 3; group++)
      {
      for (cb=0; cb < 13; cb++)
         {
         S32 m = STR->subblock_gain[gr][ch][group];
         S32 n = (1 + sf_scale) * STR->scalefac[gr][ch].s[group][cb];

         short_scalar[group][cb] = common * (*(F32*)(void*)&sfac[m]) * (*(F32*)(void*)&lfac[n]);
         }
      }

   //
   // Apply requantization and scaling formula based on block type
   //

   cb = 0;

   S32 line = 0;
   S32 end  = STR->zero_part[ch];

   F32 *xr  = &xrptr[ch][0][0];
   S16 *is  = &isptr[ch][0];
//   U8     *sgn = &STR->is_sign[ch][0];

   S32 pure_short_block = ((STR->block_type[gr][ch] == 2) &&
                          (STR->mixed_block_flag[gr][ch] == 0));

   S32 mixed_block = ((STR->block_type[gr][ch] == 2) &&
                      (STR->mixed_block_flag[gr][ch]));

   S32 window_switch = STR->window_switching_flag[gr][ch];

   S32 last_line = -1;

   while ( (line < end) && (last_line != line ) )
      {
      last_line = line;

      if (next_cb_boundary > end)
         {
         next_cb_boundary = end;
         }

      S32 group = 0;
      S32 group_end = 0;

      if (window_switch && (pure_short_block || (mixed_block && (line >= 36))))
         {
         group = (line - cb_begin) / cb_width;
         group_end = cb_begin + cb_width;
         }

      while (line < next_cb_boundary)
         {
         //
         // Do long/short dependent scaling operations
         //


         // v to the 4/3rds power

         U32 v = *is++;
         U32 av = v & 16383;
         F32 ftemp;

         if ( av < 64 )
           ftemp = *(F32*)(void*)&cr4_64[ av ];
         else if ( av < 2048 )
         {
           F32 a = *(F32*)(void*)&recp_32[ av & 31 ];
           av >>= 5;
           F32 f = *(F32*)(void*)&cr4_b32[ av ];
           ftemp = f + ( a * ( *(F32*)(void*)&cr4_b32[ av + 1 ] - f ) );
         }
         else
         {
           F32 a = *(F32*)(void*)&recp_128[ av & 127 ];
           av >>= 7;
           F32 f = *(F32*)(void*)&cr4_b128[ av ];
           ftemp = f + ( a * ( *(F32*)(void*)&cr4_b128[ av + 1 ] - f ) );
         }

         if ( v & 16384 )
           ftemp = -ftemp;


         if (window_switch && (pure_short_block || (mixed_block && (line >= 36))))
            {
            if (line >= group_end)
               {
               group_end += cb_width;
               ++group;
               }

            ftemp *= short_scalar[group][cb];
            }
         else
            {
            //
            // LONG block types 0,1,3 & 1st 2 subbands of switched blocks
            //

            ftemp *= long_scalar[cb];
            }


/*         if (*sgn++)
            {
            ftemp = -ftemp;
            }*/

         *xr++ = ftemp;

         //
         // End processing this line
         //

         ++line;
         }

      //
      // Adjust critical band boundary
      //

      if (STR->window_switching_flag[gr][ch] &&
         (STR->block_type           [gr][ch] == 2))
         {
         //
         // Short/mixed blocks
         //

         if (STR->mixed_block_flag[gr][ch])
            {
            if (line == sfBandIndex[sfreq].l[8])
               {
               next_cb_boundary = sfBandIndex[sfreq].s[4]*3;

               cb = 3;

               cb_width = sfBandIndex[sfreq].s[cb+1] -
                          sfBandIndex[sfreq].s[cb];
               cb_begin = sfBandIndex[sfreq].s[cb]*3;
               }
            else
               {
               if (line < sfBandIndex[sfreq].l[8])
                  {
                  next_cb_boundary = sfBandIndex[sfreq].l[(++cb)+1];
                  }
               else
                  {
                  next_cb_boundary = sfBandIndex[sfreq].s[(++cb)+1]*3;

                  cb_width = sfBandIndex[sfreq].s[cb+1] -
                             sfBandIndex[sfreq].s[cb];
                  cb_begin = sfBandIndex[sfreq].s[cb]*3;
                  }
               }
            }
         else
            {
            next_cb_boundary = sfBandIndex[sfreq].s[(++cb)+1]*3;

            cb_width = sfBandIndex[sfreq].s[cb+1] -
                       sfBandIndex[sfreq].s[cb];
            cb_begin = sfBandIndex[sfreq].s[cb]*3;
            }
         }
      else
         {
         //
         // Long blocks
         //

         next_cb_boundary = sfBandIndex[sfreq].l[(++cb)+1];
         }
      }

   //
   // Flush zero part
   //

   if (line < 576)
      {
      //
      // Zero part entered -- flush and return success
      //

      AIL_memset(xr,
                 0,
                 STR->zero_count[ch] * sizeof(F32));

      return 1;
      }

   //
   // Return success
   //

   return 1;
}

//############################################################################
//#                                                                          #
//# Decode layer 3 scalefactors in accordance with MPEG1 specifications      #
//#                                                                          #
//############################################################################

static S32 L3_sf_MP1(ASISTREAM *STR, S32 gr, S32 ch)
{
   S32 i,sfb,window;

   if ((STR->window_switching_flag[gr][ch]) &&
       (STR->block_type           [gr][ch] == 2))
      {
      //
      // Short or mixed block
      //

      if (STR->mixed_block_flag[gr][ch])
         {
         for (sfb = 0; sfb < 8; sfb++)
            {
            STR->scalefac[gr][ch].l[sfb] = A(slen[0][STR->scalefac_compress[gr][ch]]);
            }

         for (sfb = 3; sfb < 6; sfb++)
            {
            for (window=0; window < 3; window++)
               {
               STR->scalefac[gr][ch].s[window][sfb] = A(slen[0][STR->scalefac_compress[gr][ch]]);
               }
            }

         for (sfb = 6; sfb < 12; sfb++)
            {
            for (window=0; window < 3; window++)
               {
               STR->scalefac[gr][ch].s[window][sfb] = A(slen[1][STR->scalefac_compress[gr][ch]]);
               }
            }
         }
      else
         {
         for (i=0; i < 2; i++)
            {
            for (sfb = sfbtable.s[i]; sfb < sfbtable.s[i+1]; sfb++)
               {
               for (window=0; window < 3; window++)
                  {
                  S32 n = slen[i][STR->scalefac_compress[gr][ch]]; // Break this out for bug in PSP2 compiler.
                  STR->scalefac[gr][ch].s[window][sfb] = A(n);
                  }
               }
            }
         }

      for (window=0; window < 3; window++)
         {
         STR->scalefac[gr][ch].s[window][12] = 0;
         }
      }
   else
      {
      //
      // Long block only
      //
      // For each scalefactor band partition, scfsi[ch][partition]
      // determines whether scale factor information for granule 1
      // appears explicitly, or is copied from granule 0
      //

      for (i=0; i < 4; i++)
         {
         if ((STR->scfsi[ch][i] == 0) || (gr == 0))
            {
            for (sfb = sfbtable.l[i]; sfb < sfbtable.l[i+1]; sfb++)
               {
               STR->scalefac[gr][ch].l[sfb] = A(slen[(i < 2) ? 0 : 1][STR->scalefac_compress[gr][ch]]);
               }
            }
         else
            {
            for (sfb = sfbtable.l[i]; sfb < sfbtable.l[i+1]; sfb++)
               {
               STR->scalefac[1][ch].l[sfb] = STR->scalefac[0][ch].l[sfb];
               }
            }
         }

      STR->scalefac[gr][ch].l[22] = 0;
      }

   //
   // Return success
   //

   return 1;
}

//############################################################################
//#                                                                          #
//# Decode layer 3 scalefactors in accordance with MPEG2 specifications      #
//#                                                                          #
//############################################################################

static S32 L3_sf_MP2(ASISTREAM *STR, S32 gr, S32 ch)
{
   //S32 start = STR->apos;

   gr=gr;

   static const S32 sfb_cnts[2][3][3][4]=
      {
      {{{6,5,5,5},   {9,9,9,9},    {6,9,9,9} },
      {{6,5,7,3},    {9,9,12,6},   {6,9,12,6}},
      {{11,10,0,0},  {18,18,0,0},  {15,18,0,0}}},
      {{{7,7,7,0},   {12,12,12,0}, {6,15,12,0}},
      {{6,6,6,3},    {12,9,9,6},   {6,12,9,6}},
      {{8,8,5,0},    {15,12,9,0},  {6,18,9,0}}}
      };

   S32 slen[4];

   S32      c =              STR->scalefac_compress     [0][ch];
   S32 *p = (S32 *) &STR->preflag               [0][ch];
   S32      m =              STR->mixed_block_flag      [0][ch];
   S32      b =              STR->block_type            [0][ch];
   S32      w =              STR->window_switching_flag [0][ch];

   S32 group=0,set=0;
   S32 j,k;

   if (!(((STR->mode_extension == 0x01) || (STR->mode_extension == 0x03))
       &&
      (ch == 1)))
      {
      //
      // Either this is the left or mono channel, or this is not an
      // intensity stereo stream
      //

      group = 0;

      if (c < 400)
         {
         slen[0] = (c >> 4) / 5;
         slen[1] = (c >> 4) % 5;
         slen[2] = (c % 16) >> 2;
         slen[3] = (c % 4);

         *p = 0;
         set = 0;
         }
      else if ((400 <= c) && (c < 500))
         {
         slen[0] = ((c-400) >> 2) / 5;
         slen[1] = ((c-400) >> 2) % 5;
         slen[2] = (c-400) % 4;
         slen[3] = 0;

         *p = 0;
         set = 1;
         }
      else if ((500 <= c) )//&& (c < 512))
         {
         slen[0] = (c-500) / 3;
         slen[1] = (c-500) % 3;
         slen[2] = 0;
         slen[3] = 0;

         *p = 1;
         set = 2;
         }
      }

   else

//   if (((STR->mode_extension == 0x01) || (STR->mode_extension == 0x03))
//        &&
//       (ch == 1))

      {
      //
      // This is the right channel of an intensity stereo stream
      //

      STR->intensity_scale = c % 2;

      S32 isc = c >> 1;

      group = 1;

      if (isc < 180)
         {
         slen[0] = isc / 36;
         slen[1] = (isc % 36) / 6;
         slen[2] = (isc % 36) % 6;
         slen[3] = 0;

         *p = 0;
         set = 0;
         }
      else if ((180 <= isc) && (isc < 244))
         {
         slen[0] = ((isc-180) % 64) >> 4;
         slen[1] = ((isc-180) % 16) >> 2;
         slen[2] = (isc-180) % 4;
         slen[3] = 0;

         *p = 0;
         set = 1;
         }
      else if ((244 <= isc) )//&& (isc < 255))
         {
         slen[0] = (isc-244) / 3;
         slen[1] = (isc-244) % 3;
         slen[2] = 0;
         slen[3] = 0;

         *p = 0;
         set = 2;
         }
      }

   //
   // Get scalefactor band counts
   //

   S32 sfb_cnt[4];

   if ((w) && (b == 2))
      {
      AIL_memcpy(sfb_cnt,
                sfb_cnts[group][set][m + 1],
                4 * sizeof(S32));
      }
   else
      {
      AIL_memcpy(sfb_cnt,
                 sfb_cnts[group][set][0],
                 4 * sizeof(S32));
      }

   //
   // Decode MPEG2 scalefactors, recording limits
   //

   S32 sfb = 0;

   if ((!w) || (w && (b != 2)))
      {
      //
      // Pure long block
      //

      for (j=0; j < 4; j++)
         {
         S32 len = slen[j];
         S32 lim = (1 << len) - 1;

         for (k=0; k < sfb_cnt[j]; k++)
            {
            STR->scalefac[0][ch].l[sfb] = A(len);

            if (ch)
               {
               STR->pos_limit[sfb] = lim;
               }

            sfb++;
            }
         }
      }
   else if (b == 2)
      {
      if (!m)
         {
         //
         // Pure short block
         //

         for (j=0; j < 4; j++)
            {
            S32 len = slen[j];
            S32 lim = (1 << len) - 1;

            for (k=0; k < sfb_cnt[j]; k += 3)
               {
               STR->scalefac[0][ch].s[0][sfb] = A(len);
               STR->scalefac[0][ch].s[1][sfb] = A(len);
               STR->scalefac[0][ch].s[2][sfb] = A(len);

               if (ch)
                  {
                  STR->pos_limit[sfb + 6] = lim;
                  }

               sfb++;
               }
            }
         }
      else
         {
         //
         // Mixed block
         //

         S32 len = slen[0];
         S32 lim = (1 << len) - 1;

         for (k=0; k < 6; k++)
            {
            STR->scalefac[0][ch].l[sfb] = A(len);

            if (ch)
               {
               STR->pos_limit[sfb] = lim;
               }

            sfb++;
            }

         sfb_cnt[0] -= 6;

         sfb = 3;

         for (j=0; j < 4; j++)
            {
            S32 len = slen[j];
            S32 lim = (1 << len) - 1;

            for (k = 0; k < sfb_cnt[j]; k += 3)
               {
               STR->scalefac[0][ch].s[0][sfb] = A(len);
               STR->scalefac[0][ch].s[1][sfb] = A(len);
               STR->scalefac[0][ch].s[2][sfb] = A(len);

               if (ch)
                  {
                  STR->pos_limit[sfb + 6] = lim;
                  }

               sfb++;
               }
            }
         }
      }

   //
   // Return success
   //

   return 1;
}

//############################################################################
//#                                                                          #
//# Decode layer 3 side information and Huffman data                         #
//#                                                                          #
//############################################################################

#if defined(IS_XENON) || ( defined(IS_PS3) && !defined(IS_SPU) )
  #if defined(IS_PS3) && !defined(IS_SPU)
    #if !defined(__SNC__)
      #if defined(__rlwnm)
        #undef __rlwnm
      #endif
      #define __rlwnm(value, leftRotateBits, maskStart, maskEnd)                        \
      ({ unsigned int result;                                                        \
         __asm__ ("rlwnm %0, %1, %2, %3, %4" : "=r" (result) :                        \
                  "r" (value), "r" (leftRotateBits), "n" (maskStart), "n" (maskEnd)); \
         /*return */ result; })
    #endif
    #define _rotl( val, amt ) __rlwnm( val, amt, 0, 31  )
  #endif

  static const U32 masks[14] = { 0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191 };

#endif

static S32 L3_parse(ASISTREAM *STR, S32 gr, S32 ch, is_type * isptr)
{
   S32 part2_start = STR->apos;

   //
   // Fetch and decode scalefactors
   //

   if (STR->MPEG1)
      {
      L3_sf_MP1(STR, gr, ch);
      }
   else
      {
      L3_sf_MP2(STR, gr, ch);
      }

   //
   // Init Huffman decode information in accordance with pp. 28,29
   //

   S32 big_value = STR->big_values[gr][ch] * 2;
   S32 r[3];

   //
   // Get Huffman region boundaries
   //
   // r[0] = beginning of region 1
   // r[1] = beginning of region 2
   // r[2] = end of big_value space
   //

   S16 const *t_l = sf_bound_l[STR->MPEG1][STR->sampling_frequency];
   S16 const *t_s = sf_bound_s[STR->MPEG1][STR->sampling_frequency];

   if ((!STR->window_switching_flag[gr][ch]) &&
        (STR->block_type           [gr][ch] == 0))
      {
      //
      // Long blocks: divided into 3 regions, aligned with scalefactor
      // bands
      //

      r[0] = t_l[STR->region0_count[gr][ch]] + 1;

      if (r[0] > big_value)
         {
         r[0] = r[1] = big_value;
         }
      else
         {
         r[1] = t_l[STR->region0_count[gr][ch] +
                    STR->region1_count[gr][ch] + 1] + 1;

         if (r[1] > big_value)
            {
            r[1] = big_value;
            }
         }
      }
   else
      {
      //
      // Short or mixed blocks
      //

      if ((STR->block_type      [gr][ch] == 2) &&
         (!STR->mixed_block_flag[gr][ch]))
         {
         //
         // p. 26: If window_switching_flag is set, block type == 2,
         // and !mixed_block_flag, region0_count = 8.  Since this
         // is a short block, each band is counted 3 times, so a
         // region0_count of 8 indicates that region1 begins at
         // scalefactor band 3.  The beginning of this band is
         // represented as one past the end of band 2 (t_s[2]+1).
         //

         r[0] = 3 * (t_s[2] + 1);
         }
      else
         {
         //
         // p. 26: If this is a long block with window_switching_flag
         // set, region0_count = 7.  So region1 begins at scalefactor
         // band 8, represented as one past the end of band2 (t_l[7]+1).
         //

         r[0] = t_l[7] + 1;
         }

      if (r[0] > big_value)
         {
         r[0] = big_value;
         }

      //
      // Regardless of window type, in a short or mixed block
      // all remaining values in the big_value region are contained
      // in region 1
      //

      r[1] = big_value;
      }

   r[2] = big_value;

   //
   // Decode Huffman frequency-coefficient pairs from big_values
   // partition (regions 0, 1, 2)
   //

   S16 * is     = &isptr[ch][0];
   S16 * is_end = is + 576;

   register U32 count = STR->apos & 7;
   register U8 * ptr = (U8*) &STR->audio_buffer[ STR->apos >> 3 ];
   register U32 bits;

   bits = ( ( ( (U32) ptr[ 0 ] ) << 24 ) | ( ( (U32) ptr[ 1 ] ) << 16 ) | ( ( (U32) ptr[ 2 ] ) << 8 ) | ( (U32) ptr[ 3 ] ) ) << count;
   ptr += 4;
   count = 32 - count;

   for (S32 rgn=0; rgn < 3; rgn++)
   {
      S32  n           = STR->table_select[gr][ch][rgn];
      S16 * is_rgn_end = &isptr[ch][0] + r[ rgn ];
      U32 esclen       = h_linbits[n];

      // prevent overwrites by malformed MP3 frames
      if ( is_rgn_end > is_end )
        is_rgn_end = is_end;

      if (n == 0)
      {
         AIL_memset(is, 0, AIL_ptr_dif( is_rgn_end, is ) );
         is = is_rgn_end;
      }
      else
      {
         const U8 * tbl = mp3_htbls - 2 + n + n;
         U32 ts = LE_SWAP16( tbl );
         tbl += ( ( ts + ts ) & 0x1fff );
         ts >>= 15;

         while ( is < is_rgn_end )
         {
            //
            // Decode Huffman pair at current bitstream position
            //

            const U8 * c  = tbl;
            U32 val;

            if ( count < 8 )
            {
              bits |= ( ( ( ( (U32) ptr[ 0 ] ) << 16 ) | ( ( (U32) ptr[ 1 ] ) << 8 ) | ( (U32) ptr[ 2 ] ) ) << ( 8 - count ) );
              count += 24;
              ptr += 3;
            }

            U32 code;

            if ( ts & 1 )
            {
              // by 8
              code = bits >> 24;

              c = c + code + code;
              val = LE_SWAP16( c );

              if ( val & 15 )
                goto found_in_acc;

              bits <<= 8;
              count -= 8;
            }
            else
            {
              // by 5
              code = bits >> 27;

              c = c + code + code;
              val = LE_SWAP16( c );

              if ( val & 15 )
              {
               found_in_acc:
                U32 b = val & 15;
                val >>= 8;
                bits <<= b;
                count -= b;
                goto store;
              }

              bits <<= 5;
              count -= 5;
            }

            c += ( ( val >> 4 ) & 0x3ff );
            val >>= 8;

            for(;;)
            {
              if ( count == 0 )
              {
                count = 32;
                bits = ( ( (U32) ptr[ 0 ] ) << 24 ) |( ( (U32) ptr[ 1 ] ) << 16 ) | ( ( (U32) ptr[ 2 ] ) << 8 ) | ( (U32) ptr[ 3 ] );
                ptr += 4;
              }

              if ( bits & 0x80000000 )
              {
                ++c;
                val <<= 1;
              }
              bits += bits;
              --count;

              if ( val & 0x80 )
              {
                val = *c;
                goto store;
              }
              val = *c;
              c += ( val & 0x3f );
            }

           store:

            //
            // fetch sign bits and escape codes
            //

            if ( esclen > 0 )
            {
              U32 coeff = val & 15;
              val >>= 4;

              if ( coeff )
              {
                if ( coeff == 15 )
                {
                  if ( count <= esclen )  // get extra bit for sign bit
                  {
                    bits |= ( ( ( ( (U32) ptr[ 0 ] ) << 8 ) | ( (U32) ptr[ 1 ] ) ) << ( 16 - count ) );
                    count += 16;
                    ptr += 2;
                  }

                  #if defined(IS_XENON) || ( defined(IS_PS3) && !defined(IS_SPU) )
                    bits = _rotl( bits, esclen );
                    U32 mask = masks[ esclen ];
                    coeff += ( bits & mask );
                    bits &= ~mask;
                    count -= esclen;
                  #else
                    coeff += ( bits >> ( 32 - esclen ) );
                    bits <<= esclen;
                    count -= esclen;
                  #endif
                }

                if ( count == 0 )
                {
                  count = 32;
                  bits = ( ( (U32) ptr[ 0 ] ) << 24 ) |( ( (U32) ptr[ 1 ] ) << 16 ) | ( ( (U32) ptr[ 2 ] ) << 8 ) | ( (U32) ptr[ 3 ] );
                  ptr += 4;
                }

                if ( bits & 0x80000000 )
                  coeff |= 16384;
                bits += bits;
                --count;
              }
              is[ 0 ] = (S16) coeff;

              coeff = val & 15;
              if ( coeff )
              {
                if ( coeff == 15 )
                {
                  if ( count <= esclen ) // get extra bit for sign bit
                  {
                    bits |= ( ( ( ( (U32) ptr[ 0 ] ) << 8 ) | ( (U32) ptr[ 1 ] ) ) << ( 16 - count ) );
                    count += 16;
                    ptr += 2;
                  }

                  #if defined(__RADXENON__) || defined(__RADPS3__)
                    bits = _rotl( bits, esclen );
                    U32 mask = masks[ esclen ];
                    coeff += ( bits & mask );
                    bits &= ~mask;
                    count -= esclen;
                  #else
                    coeff += ( bits >> ( 32 - esclen ) );
                    bits <<= esclen;
                    count -= esclen;
                  #endif
                }

                if ( count == 0 )
                {
                  count = 32;
                  bits = ( ( (U32) ptr[ 0 ] ) << 24 ) |( ( (U32) ptr[ 1 ] ) << 16 ) | ( ( (U32) ptr[ 2 ] ) << 8 ) | ( (U32) ptr[ 3 ] );
                  ptr += 4;
                }

                if ( bits & 0x80000000 )
                  coeff |= 16384;
                bits += bits;
                --count;
              }
              is[ 1 ] = (S16) coeff;
              is += 2;
            }
            else
            {

              if ( count < 2 )
              {
                bits |= ( ( ( ( (U32) ptr[ 0 ] ) << 16 ) | ( ( (U32) ptr[ 1 ] ) << 8 ) | ( (U32) ptr[ 2 ] ) ) << ( 8 - count ) );
                count += 24;
                ptr += 3;
              }

              U32 coeff = val & 15;
              val >>= 4;

              if ( coeff )
              {
                if ( bits & 0x80000000 )
                  coeff |= 16384;
                bits += bits;
                --count;
              }
              is[ 0 ] = (S16) coeff;

              coeff = val & 15;
              if ( coeff )
              {
                if ( bits & 0x80000000 )
                  coeff |= 16384;
                bits += bits;
                --count;
              }
              is[ 1 ] = (S16) coeff;
              is += 2;
            }
         }
      }
   }

   //
   // Calculate size of count1 partition
   //
   // count1 size = difference between part2_3_length and # of bits
   // read so far
   //

   S32 n = STR->count1table_select[gr][ch] + 32;

   const U8 * tbl = mp3_htbls - 2 + n + n;
   U32 ts = LE_SWAP16( tbl );
   tbl += ( ( ts + ts ) & 0x1fff );

   #ifdef _DEBUG
     if ( ( ts >> 12 ) != 6 ) MSSBreakPoint();
   #endif

   S32 part3_end = part2_start + STR->part2_3_length[gr][ch];

   S32 apos = ( ( (S32) AIL_ptr_dif( ptr, STR->audio_buffer ) ) << 3 ) - count;

   while ( apos < part3_end )
   {
      if ( is >= is_end )
         break;

      //
      // Decode Huffman (the 32nd and 33rd tables always use a direct 6-bit accel table)
      //

      U32 val;

      if ( count < 8 )
      {
         bits |= ( ( ( ( (U32) ptr[ 0 ] ) << 16 ) | ( ( (U32) ptr[ 1 ] ) << 8 ) | ( (U32) ptr[ 2 ] ) ) << ( 8 - count ) );
         count += 24;
         ptr += 3;
      }

      // by 6
      U32 code = bits >> 26;

      val = LE_SWAP16( ( tbl + code + code ) );

      U32 b = val & 15;

      #ifdef _DEBUG
        if ( b == 0 ) MSSBreakPoint();
      #endif

      val >>= 8;
      bits <<= b;
      count -= b;
      apos += b;

      //
      // Unpack coefficient quad, and fetch sign bits
      //

      if ( count < 4 )
      {
         bits |= ( ( ( ( (U32) ptr[ 0 ] ) << 16 ) | ( ( (U32) ptr[ 1 ] ) << 8 ) | ( (U32) ptr[ 2 ] ) ) << ( 8 - count ) );
         count += 24;
         ptr += 3;
      }

      S32 coeff = ( val & 8 ) >> 3;
      if ( coeff )
      {
        if ( bits & 0x80000000 )
          coeff |= 16384;
        bits += bits;
        --count;
        ++apos;
      }
      is[ 0 ] = (S16) coeff;

      coeff = ( val & 4 ) >> 2;
      if ( coeff )
      {
        if ( bits & 0x80000000 )
          coeff |= 16384;
        bits += bits;
        --count;
        ++apos;
      }
      is[ 1 ] = (S16) coeff;

      coeff = ( val & 2 ) >> 1;
      if ( coeff )
      {
        if ( bits & 0x80000000 )
          coeff |= 16384;
        bits += bits;
        --count;
        ++apos;
      }
      is[ 2 ] = (S16) coeff;

      coeff = val & 1;
      if ( coeff )
      {
        if ( bits & 0x80000000 )
          coeff |= 16384;
        bits += bits;
        --count;
        ++apos;
      }
      is[ 3 ] = (S16) coeff;

      is += 4;
   }

   //
   // Skip past any padding or ancillary data to reach next channel
   //

   STR->apos = part3_end;


   //
   // Log beginning of zero part of frequency spectrum
   //

   if ( is >= is_end )
   {
      STR->zero_part[ch] = 576;
      STR->zero_count[ch] = 0;
   }
   else
   {
      S32 line = (S32) ( is - &isptr[ch][0] );
      STR->zero_part[ch] = line;

     //
     // Flush remainder of channel's frequency-line set with zeroes
     //

     STR->zero_count[ch] = (576 - line);
     AIL_memset(is, 0, AIL_ptr_dif( is_end, is ) );
   }

   //
   // Return success
   //

   return 1;
}

//############################################################################
//#                                                                          #
//# Calculate scaling values for MPEG 2 Layer 3 stereo processing            #
//#                                                                          #
//############################################################################

inline void L3_stereo_k_values(S32 is_pos, //)
                               F32 io,
                               S32 i,
                               F32 k[2][576])
{
    F32 t;
    float *k0 = &k[0][i];
    float *k1 = &k[1][i];

    switch (is_pos)
    {
    case 0:
        *k0 = 1.0F;
        *k1 = 1.0F;
        break;

    case 1:
        *k0 = io;
        *k1 = 1;
        break;

    case 2:
        *k0 = 1;
        *k1 = io;
        break;

    case 3:
        *k0 = io * io;
        *k1 = 1;
        break;

    case 4:
        *k0 = 1;
        *k1 = io * io;
        break;

    case 5:
        *k0 = io * io * io;
        *k1 = 1;
        break;

    case 6:
        *k0 = 1;
        *k1 = io * io * io;
        break;

    case 7:
        t = io * io;
        *k0 = t * t;
        *k1 = 1;
        break;

    case 8:
        t = io * io;
        *k0 = 1;
        *k1 = t * t;
        break;

    case 9:
        t = io * io;
        *k0 = t * t * io;
        *k1 = 1;
        break;

    case 10:
        t = io * io;
        *k0 = 1;
        *k1 = t * t * io;
        break;

    case 11:
        t = io * io * io;
        *k0 = t * t;
        *k1 = 1;
        break;

    case 12:
        t = io * io * io;
        *k0 = 1;
        *k1 = t * t;
        break;

    case 13:
        t = io * io * io;
        *k0 = t * t * io;
        *k1 = 1;
        break;

    case 14:
        t = io * io * io;
        *k0 = 1;
        *k1 = t * t * io;
        break;

    case 15:
        t = io * io;
        t = t * t;
        *k0 = t * t;
        *k1 = 1;
        break;

    case 16:
        t = io * io;
        t = t * t;
        *k0 = 1;
        *k1 = t * t;
        break;

    default:
        if ((is_pos % 2) == 1)
        {
            *k0 = AIL_pow(io,(F32) ((is_pos + 1) / 2));
            *k1 = 1;
        }
        else
        {
            *k0 = 1;
            *k1 = AIL_pow(io,(F32) (is_pos / 2));
        }

        break;
    }
}

//############################################################################
//#                                                                          #
//# Perform stereo processing                                                #
//#                                                                          #
//############################################################################

static S32 L3_stereo(ASISTREAM *STR, //)
                     S32            gr,
                     xr_type   *xrptr,
                     xr_type   *lrptr)
{

   //
   // Initialization
   //

   S32 sfreq  = STR->sampling_frequency + (STR->MPEG1 * 3);
   const S16 *psfBandIndex_l = sfBandIndex[sfreq].l;
   const S16 *psfBandIndex_s = sfBandIndex[sfreq].s;
   S32 stereo = STR->nch;

   S32 ms_stereo = (STR->mode == MPG_MD_JOINT_STEREO) &&
                   (STR->mode_extension & 0x2);

   S32 i_stereo  = (STR->mode == MPG_MD_JOINT_STEREO) &&
                   (STR->mode_extension & 0x1);

   S32    i,j,sb,ss,sfb;
   static F32 is_ratio [576];
   static F32 io;
   static F32 k     [2][576];
   U8     is_pos   [576];

#if 1
    AIL_memset(is_pos, 7, sizeof(is_pos));
#else
   for (i=0; i < 576; i++)
      {
      is_pos[i] = 7;
      }
#endif

   if ((STR->scalefac_compress[gr][0] % 2) == 1)
      {
      io = 0.707106781188F;
      }
   else
      {
      io = 0.840896415256F;
      }

   //
   // Perform intensity stereo processing
   //

    if ((stereo == 2) && i_stereo)
      {
      if (STR->window_switching_flag[gr][0] &&
         (STR->block_type           [gr][0] == 2))
         {

          if (STR->mixed_block_flag[gr][0])
            {
            //
            // Mixed short/long block
            //

            S32 max_sfb = 0;

            for (j=0; j < 3; j++)
               {
               S32 sfbcnt = 2;
               S32 *str_scalefac = STR->scalefac[gr][1].s[j];

               for (sfb = 12; sfb >= 3; sfb--)
                  {
                  S32 lines = psfBandIndex_s[sfb+1] -
                              psfBandIndex_s[sfb];

                  i = 3 * psfBandIndex_s[sfb] + (j+1) * lines - 1;

                  while (lines > 0)
                     {
                     //$ TODO: This didn't seem to get hit but we can remove
                     //        the entire i and SSLIMIT thing like we did below.
                     //        Search for F32 *str_xr in the loop south of here.
                     if (xrptr[1][i / SSLIMIT][i % SSLIMIT] != 0.0f)
                        {
                        sfbcnt = sfb;
                        sfb    = -10;
                        lines  = -10;
                        }

                     lines--;
                     i--;
                     }
                  }

               sfb = sfbcnt + 1;

               if (sfb > max_sfb)
                  {
                  max_sfb = sfb;
                  }

               while (sfb < 12)
                  {
                  sb = psfBandIndex_s[sfb+1] -
                       psfBandIndex_s[sfb];

                  i = 3 * psfBandIndex_s[sfb] + j * sb;

                  for (; sb > 0; sb--)
                     {
                     if (i >= 576) break;

                     is_pos[i] = (U8) str_scalefac[sfb];

                     if (is_pos[i] != 7)
                        {
                        if (!STR->MPEG1)
                           {
                           L3_stereo_k_values(is_pos[i],io,i,k);
                           }
                        else
                           {
                           is_ratio[i] = AIL_tan(is_pos[i] * (PI / 12.0f));
                           }
                        }

                     i++;
                     }

                  sfb++;
                  }

               sb  = psfBandIndex_s[12] -
                     psfBandIndex_s[11];

               sfb = 3 * psfBandIndex_s[11] + j * sb;

               sb  = psfBandIndex_s[13] -
                     psfBandIndex_s[12];

               i   = 3 * psfBandIndex_s[11] + j * sb;

               for (; sb > 0; sb--)
                  {
                  if (i >= 576) break;

                  is_pos  [i] = is_pos[sfb];
                  is_ratio[i] = is_ratio[sfb];
                  k[0][i]     = k[0][sfb];
                  k[1][i]     = k[1][sfb];

                  i++;
                  }
               }

            if (max_sfb <= 3)
               {
               i  = 2;
               ss = 17;
               sb = -1;

               while (i >= 0)
                  {
                  if (xrptr[1][i][ss] != 0.0f)
                     {
                     sb = i * 18 + ss;
                     i = -1;
                     }
                  else
                     {
                     ss--;

                     if (ss < 0)
                        {
                        i--;
                        ss = 17;
                        }
                     }
                  }

               i = 0;

               while (psfBandIndex_l[i] <= sb)
                  {
                  i++;
                  if (i >= 576) break;
                  }

               sfb = i;

               i = psfBandIndex_l[i];

               for (; sfb < 8; sfb++)
                  {
                  sb = psfBandIndex_l[sfb+1] -
                       psfBandIndex_l[sfb];

                  for (; sb > 0; sb--)
                     {
                     if (i >= 576) break;

                     is_pos[i] = (U8) STR->scalefac[gr][1].l[sfb];

                     if (is_pos[i] != 7)
                        {
                        if (!STR->MPEG1)
                           {
                           L3_stereo_k_values(is_pos[i],io,i,k);
                           }
                        else
                           {
                           is_ratio[i] = AIL_tan(is_pos[i] * (PI / 12));
                           }
                        }

                     i++;
                     }
                  }
               }
            }
         else
            {
            //
            // Pure short block
            //

            for (j = 0; j < 3; j++)
               {
               S32 sfbcnt = -1;
               S32 *str_scalefac = STR->scalefac[gr][1].s[j];

               for (sfb = 12; sfb >=0; sfb--)
                  {
                  S32 lines = psfBandIndex_s[sfb+1] -
                              psfBandIndex_s[sfb];

                  i = 3 * psfBandIndex_s[sfb] + (j+1) * lines - 1;

#if 1
                    // mp3dec.h:
                    //  F32 xr[2][32][18];
                    //  #define SSLIMIT 18
                    F32 *str_xr = &xrptr[1][i / SSLIMIT][i % SSLIMIT];

                    while (lines-- > 0)
                    {
                        if (*str_xr-- != 0.0f)
                        {
                            sfbcnt = sfb;
                            sfb    = -10;
                            break;
                        }
                    }
#else
                  while (lines > 0)
                     {
                     if (xrptr[1][i / SSLIMIT][i % SSLIMIT] != 0.0f)
                        {
                        sfbcnt = sfb;
                        sfb    = -10;
                        lines  = -10;
                        }

                     lines--;
                     i--;
                     }
#endif
                  }

               sfb = sfbcnt + 1;

               while (sfb < 12)
                  {
                  sb = psfBandIndex_s[sfb+1] -
                       psfBandIndex_s[sfb];

                  i = 3 * psfBandIndex_s[sfb] + j * sb;

                  for (; sb > 0; sb--)
                     {
                     if (i >= 576) break;

                     is_pos[i] = (U8) str_scalefac[sfb];

                     if (is_pos[i] != 7)
                        {
                        if (!STR->MPEG1)
                           {
                           L3_stereo_k_values(is_pos[i],io,i,k);
                           }
                        else
                           {
                           is_ratio[i] = AIL_tan(is_pos[i] * (PI / 12));
                           }
                        }

                     i++;
                     }
                  sfb++;
                  }

               sb = psfBandIndex_s[12] -
                    psfBandIndex_s[11];

               sfb = 3 * psfBandIndex_s[11] + j * sb;

               sb = psfBandIndex_s[13] -
                    psfBandIndex_s[12];

               i = 3 * psfBandIndex_s[11] + j * sb;

               for (; sb > 0; sb--)
                  {
                  if (i >= 576) break;

                  is_pos  [i] = is_pos[sfb];
                  is_ratio[i] = is_ratio[sfb];
                  k[0][i]     = k[0][sfb];
                  k[1][i]     = k[1][sfb];

                  i++;
                  }
               }
            }
         }
      else
         {
         //
         // Pure long block
         //

        //
        // This just searches backward from the end of xr[1] for the first non-zero entry
        // It improved performance quite a bit to do it as a one-dimensional operation
        // rather than with two nested loops and an array lookup
        //

        {
            F32 *pxr = &((F32 *)&(xrptr[1][0][0]))[31 * 18 + 17];
            F32 *pxrlimit = &((F32 *)&(xrptr[1][0][0]))[0];

            do
            {
                if (*(S32 *)pxr != 0)
                {
                    if (*pxr != 0.0f)
                    {
                        sb = (S32) ( pxr - pxrlimit );
                        goto ExitLoop;
                    }
                }

                if (*(S32 *)(pxr - 1) != 0)
                {
                    if (*(pxr - 1) != 0.0f)
                    {
                        sb = (S32) ( (pxr - 1) - pxrlimit );
                        goto ExitLoop;
                    }
                }

                pxr -= 2;
            } while (pxr >= pxrlimit);

            sb = 0;

ExitLoop:;
        }

         i = 0;

         while (psfBandIndex_l[i] <= sb)
            {
            if (i >= 576) break;
            i++;
            }

         S32 *pscalefac_l = STR->scalefac[gr][1].l;

         sfb = i;
         i   = psfBandIndex_l[i];

         for (; sfb < 21; sfb++)
            {
            sb = psfBandIndex_l[sfb+1] -
                 psfBandIndex_l[sfb];

            S32 i_max = i + sb;

            if (i_max > 576)
            {
                i_max = 576;
            }
#if 0
            for (; i < i_max; i++)
               {
               is_pos[i] = (U8) STR->scalefac[gr][1].l[sfb];

               if (is_pos[i] != 7)
                  {
                  if (!STR->MPEG1)
                     {
                     L3_stereo_k_values(is_pos[i],io,i,k);
                     }
                  else
                     {
                     is_ratio[i] = AIL_tan(is_pos[i] * (PI / 12));
                     }
                  }
               }
#else
            if (!STR->MPEG1)
            {
                for (; i < i_max; i++)
                {
                    is_pos[i] = (U8) pscalefac_l[sfb];

                    if (is_pos[i] != 7)
                    {
                        L3_stereo_k_values(is_pos[i],io,i,k);
                    }
                }
            }
            else
            {
                for (; i < i_max; i++)
                {
                    is_pos[i] = (U8) pscalefac_l[sfb];

                    if (is_pos[i] != 7)
                    {
                        is_ratio[i] = AIL_tan(is_pos[i] * (PI / 12));
                    }
                }
            }
#endif
            }

         sfb = psfBandIndex_l[20];

         for (sb = 576 - psfBandIndex_l[21]; sb > 0; sb--)
            {
            //
            // NB: Derived from ISO reference source, which can crash
            // on some files if check below not made
            //

            if (i >= 576) break;

            is_pos[i]   = is_pos[sfb];
            is_ratio[i] = is_ratio[sfb];
            k[0][i]     = k[0][sfb];
            k[1][i]     = k[1][sfb];

            i++;
            }
         }
      }

   //
   // Write demultiplexed data to output array, reordering as well
   // where appropriate
   //

#if ( defined(ISO_DCT) && ISO_DCT )
   S16 const *xchg = reord_ft[STR->sampling_frequency];
#else
   S16 const *xchg = reord_ft[STR->MPEG1][STR->sampling_frequency];
#endif

   F32 *ld = lrptr[0][0];
   F32 *rd = lrptr[1][0];

   F32 *ls = xrptr[0][0];
   F32 *rs = xrptr[1][0];

   U8  *pis_pos;

   i = 0;
   pis_pos = is_pos;

    if (stereo == 2)
    {
        if(!STR->window_switching_flag[gr][0] && !STR->window_switching_flag[gr][1])
        {
            if(ms_stereo && i_stereo && !STR->MPEG1)
            {
                for (; i < 576; i++, pis_pos++)
                {
                    if (*pis_pos == 7)
                    {
                        ld[i] = (ls[i] + rs[i]) * 0.707106781f;
                        rd[i] = (ls[i] - rs[i]) * 0.707106781f;
                    }
                    else
                    {
                        ld[i] = ls[i] * k[0][i];
                        rd[i] = ls[i] * k[1][i];
                    }
                }
            }
            else
            {
                for (; i < 576; i++, pis_pos++)
                {
                    if (*pis_pos == 7)
                    {
                        if (ms_stereo)
                        {
                            ld[i] = (ls[i] + rs[i]) * 0.707106781f;
                            rd[i] = (ls[i] - rs[i]) * 0.707106781f;
                        }
                        else
                        {
                            ld[i] = ls[i];
                            rd[i] = rs[i];
                        }
                    }
                    else
                    {
                        if (i_stereo)
                        {
                            if (!STR->MPEG1)
                            {
                                ld[i] = ls[i] * k[0][i];
                                rd[i] = ls[i] * k[1][i];
                            }
                            else
                            {
                                ld[i] = ls[i] * (is_ratio[i] / (1 + is_ratio[i]));
                                rd[i] = ls[i] * (1 / (1 + is_ratio[i]));
                            }
                        }
                    }
                }
            }
        }
        else
        {
            F32 *pk = k[0];
            F32 *pl = ld;

            if (STR->window_switching_flag[gr][0] && (STR->block_type[gr][0] == 2))
            {
                if (STR->mixed_block_flag[gr][0])
                {
                    for (; i < 36; i++, pis_pos++)
                    {
                        if (*pis_pos == 7)
                        {
                            if (ms_stereo)
                            {
                                pl[i] = (ls[i] + rs[i]) * 0.707106781f;
                            }
                            else
                            {
                                pl[i] = ls[i];
                            }
                        }
                        else
                        {
                            if (i_stereo)
                            {
                                if (!STR->MPEG1)
                                {
                                    pl[i] = ls[i] * pk[i];
                                }
                                else
                                {
                                    pl[i] = ls[i] * (is_ratio[i] / (1 + is_ratio[i]));
                                }
                            }
                        }
                    }
                }

                for (; i < 576; i++, pis_pos++)
                {
                    if (*pis_pos == 7)
                    {
                        if (ms_stereo)
                        {
                            pl[xchg[i]] = (ls[i] + rs[i]) * 0.707106781f;
                        }
                        else
                        {
                            pl[xchg[i]] = ls[i];
                        }
                    }
                    else
                    {
                        if (i_stereo)
                        {
                            if (!STR->MPEG1)
                            {
                                pl[xchg[i]] = ls[i] * pk[i];
                            }
                            else
                            {
                                pl[xchg[i]] = ls[i] * (is_ratio[i] / (1 + is_ratio[i]));
                            }
                        }
                    }
                }
            }
            else
            {
                for (; i < 576; i++, pis_pos++)
                {
                    if (*pis_pos == 7)
                    {
                        if (ms_stereo)
                        {
                            pl[i] = (ls[i] + rs[i]) * 0.707106781f;
                        }
                        else
                        {
                            pl[i] = ls[i];
                        }
                    }
                    else
                    {
                        if (i_stereo)
                        {
                            if (!STR->MPEG1)
                            {
                                pl[i] = ls[i] * pk[i];
                            }
                            else
                            {
                                pl[i] = ls[i] * (is_ratio[i] / (1 + is_ratio[i]));
                            }
                        }
                    }
                }
            }

            //
            // Right channel
            //

            i = 0;
            pis_pos = is_pos;
            pk = k[1];
            pl = rd;

            if (STR->window_switching_flag[gr][1] && (STR->block_type[gr][1] == 2))
            {
                if (STR->mixed_block_flag[gr][1])
                {
                    for (; i < 36; i++, pis_pos++)
                    {
                        if (*pis_pos == 7)
                        {
                            if (ms_stereo)
                            {
                                pl[i] = (ls[i] - rs[i]) * 0.707106781f;
                            }
                            else
                            {
                                pl[i] = rs[i];
                            }
                        }
                        else
                        {
                            if (i_stereo)
                            {
                                if (!STR->MPEG1)
                                {
                                    pl[i] = ls[i] * pk[i];
                                }
                                else
                                {
                                    pl[i] = ls[i] * (1 / (1 + is_ratio[i]));
                                }
                            }
                        }
                    }
                }

                for (; i < 576; i++, pis_pos++)
                {
                    if (*pis_pos == 7)
                    {
                        if (ms_stereo)
                        {
                            pl[xchg[i]] = (ls[i] - rs[i]) * 0.707106781f;
                        }
                        else
                        {
                            pl[xchg[i]] = rs[i];
                        }
                    }
                    else
                    {
                        if (i_stereo)
                        {
                            if (!STR->MPEG1)
                            {
                                pl[xchg[i]] = ls[i] * pk[i];
                            }
                            else
                            {
                                pl[xchg[i]] = ls[i] * (1 / (1 + is_ratio[i]));
                            }
                        }
                    }
                }
            }
            else
            {
                for (; i < 576; i++, pis_pos++)
                {
                    if (*pis_pos == 7)
                    {
                        if (ms_stereo)
                        {
                            pl[i] = (ls[i] - rs[i]) * 0.707106781f;
                        }
                        else
                        {
                            pl[i] = rs[i];
                        }
                    }
                    else
                    {
                        if (i_stereo)
                        {
                            if (!STR->MPEG1)
                            {
                                pl[i] = ls[i] * pk[i];
                            }
                            else
                            {
                                pl[i] = ls[i] * (1 / (1 + is_ratio[i]));
                            }
                        }
                    }
                }
            }
        }
    }
    else
    {
      //
      // Mono
      //

      if (STR->window_switching_flag[gr][0] && (STR->block_type[gr][0] == 2))
         {
         if (STR->mixed_block_flag[gr][0])
            {
            while (i++ < 36)
               {
               *ld++ = *ls++;
               }
            }

         while (i < 576)
            {
            ld[xchg[i++]] = *ls++;
            }
         }
      else
         {
         while (i++ < 576)
            {
            *ld++ = *ls++;
            }
         }
      }

   //
   // Return success
   //

   return 1;
}

//############################################################################
//#                                                                          #
//#  Perform antialiasing pass                                               #
//#                                                                          #
//############################################################################

static S32 L3_antialias(ASISTREAM *STR, //)
                        S32            gr,
                        S32            ch,
                        xr_type   *lrptr)
{
   if ((STR->window_switching_flag[gr][ch]) &&
       (STR->block_type           [gr][ch] == 2))
      {
      return 1;
      }

   for (S32 sb=1; sb < 32; sb++)
      {
      F32 *x = lrptr[ch][sb];

      F32 a, b;

      a = x[0];
      b = x[-1];
      x[-1] = b * Cs[0] - a * Ca[0];
      x[0]  = a * Cs[0] + b * Ca[0];

      a = x[1];
      b = x[-2];
      x[-2] = b * Cs[1] - a * Ca[1];
      x[1]  = a * Cs[1] + b * Ca[1];

      a = x[2];
      b = x[-3];
      x[-3] = b * Cs[2] - a * Ca[2];
      x[2]  = a * Cs[2] + b * Ca[2];

      a = x[3];
      b = x[-4];
      x[-4] = b * Cs[3] - a * Ca[3];
      x[3]  = a * Cs[3] + b * Ca[3];

      a = x[4];
      b = x[-5];
      x[-5] = b * Cs[4] - a * Ca[4];
      x[4]  = a * Cs[4] + b * Ca[4];

      a = x[5];
      b = x[-6];
      x[-6] = b * Cs[5] - a * Ca[5];
      x[5]  = a * Cs[5] + b * Ca[5];

      a = x[6];
      b = x[-7];
      x[-7] = b * Cs[6] - a * Ca[6];
      x[6]  = a * Cs[6] + b * Ca[6];

      a = x[7];
      b = x[-8];
      x[-8] = b * Cs[7] - a * Ca[7];
      x[7]  = a * Cs[7] + b * Ca[7];
      }

   return 1;
}

#ifndef MSS_SPU_PROCESS

//############################################################################
//#                                                                          #
//# Get statistics for Layer 3 frame                                         #
//#                                                                          #
//############################################################################

S32 L3_frame_info(ASISTREAM *STR)
{
   if (STR->MPEG1)
      {
      //
      // MPEG 1: Mono=17, stereo=32 bytes
      //

      STR->side_info_size = (STR->mode == 3) ? 17 : 32;
      }
   else
      {
      //
      // MPEG2: Mono=9, stereo=17 bytes
      //

      STR->side_info_size = (STR->mode == 3) ? 9 : 17;
      }

   //
   // Read side info block into header buffer
   //

   S32 result = call_fetch_CB(STR,
                              STR->user,
                             &STR->header_buffer[STR->header_size],
                              STR->side_info_size,
                             -1);

   if (result != STR->side_info_size)
      {
      AIL_strcpy(ASI_error_text,"Invalid MPEG audio stream");
      return 0;
      }

   STR->current_offset += STR->side_info_size;

   //
   // Get main data offset word and skip private bits
   //

   STR->nch = (STR->mode == 3) ? 1 : 2;
   STR->ngr = (STR->MPEG1) ? 2 : 1;

   if (STR->MPEG1)
      {
      STR->main_data_begin = H(9);
      (STR->nch == 1) ? H(5) : H(3);
      }
   else
      {
      STR->main_data_begin = H(8);
      (STR->nch == 1) ? H(1) : H(2);
      }

   //
   // Get MPEG1 scale factor selection information
   //

   if (STR->MPEG1)
      {
      for (S32 ch=0; ch < STR->nch; ch++)
         {
         for (S32 scfsi_band=0; scfsi_band < 4; scfsi_band++)
            {
            STR->scfsi[ch][scfsi_band] = H(1);
            }
         }
      }

   //
   // Read MPEG1 / MPEG2 BC granule configuration data
   //

   S32 c_bits = (STR->MPEG1) ? 4 : 9;

   for (S32 gr=0; gr < STR->ngr; gr++)
      {
      for (S32 ch=0; ch < STR->nch; ch++)
         {
         STR->part2_3_length       [gr][ch] = H(12);
         STR->big_values           [gr][ch] = H(9);
         STR->global_gain          [gr][ch] = H(8);
         STR->scalefac_compress    [gr][ch] = H(c_bits);
         STR->window_switching_flag[gr][ch] = H(1);

         if (STR->window_switching_flag[gr][ch])
            {
            STR->block_type      [gr][ch] = H(2);
            STR->mixed_block_flag[gr][ch] = H(1);

            for (S32 region=0; region < 2; region++)
               {
               STR->table_select[gr][ch][region] = H(5);
               }

            STR->table_select[gr][ch][2] = 0;

            for (S32 window=0; window < 3; window++)
               {
               STR->subblock_gain[gr][ch][window] = H(3);
               }
            }
         else
            {
            STR->block_type      [gr][ch] = 0;
            STR->mixed_block_flag[gr][ch] = 0;

            for (S32 region=0; region < 3; region++)
               {
               STR->table_select[gr][ch][region] = H(5);
               }

            STR->region0_count[gr][ch] = H(4);
            STR->region1_count[gr][ch] = H(3);
            }

         if (STR->MPEG1)
            {
            STR->preflag[gr][ch] = H(1);
            }

         STR->scalefac_scale    [gr][ch] = H(1);
         STR->count1table_select[gr][ch] = H(1);
         }
      }

   //
   // Calculate average and actual frame size
   //
   // In Layer 3, MPEG2 has only one granule per frame, while MPEG1 has two
   //

   STR->bit_rate = bit_rate[STR->MPEG1][STR->bitrate_index];

   STR->sample_rate = sample_rate[STR->MPEG25][STR->MPEG1][STR->sampling_frequency];

   if (STR->MPEG1)
      {
      STR->average_frame_size = (144 * STR->bit_rate) / STR->sample_rate;
      }
   else
      {
      STR->average_frame_size = (72 * STR->bit_rate) / STR->sample_rate;
      }

   STR->data_size = STR->average_frame_size + STR->padding_bit - (STR->header_size + STR->side_info_size);

   if ( STR->data_size < 0 )
     STR->data_size = 0;

   return 1;
}

#endif

//############################################################################
//#                                                                          #
//# Decode frame of Layer 3 audio data                                       #
//#                                                                          #
//############################################################################

extern "C" S32 L3_frame(ASISTREAM *STR)

{
#ifdef IS_PS2
   bool use_scratchpad       = (AIL_scratchpad_policy() != MSS_DO_NOT_USE);
   bool check_SPR_completion = FALSE;

   unsigned int dstart,dend,irq;

   void *uSPR   = (void *) SPR_U_START;
   void *resSPR = (void *) SPR_RES_START;
   void *sSPR   = (void *) SPR_S_START;
   void *lrSPR  = (void *) SPR_LR_START;

   if (use_scratchpad)
      {
      //
      // Tell core system that scratchpad is being used this interrupt, so its original contents can be
      // restored at EOI
      //

      AIL_set_scratchpad_policy(MSS_USED);

      //
      // Make sure DMA is completed in both directions, so we can be
      // sure the copy of u and s out of scratchpad is completed
      //

      while (*D8_CHCR & D_CHCR_STR_M)
         {
         }

      while (*D9_CHCR & D_CHCR_STR_M)
         {
         }

      //
      // DMA STR->u and STR->s into scratchpad
      //
      // When there's only one channel we could probably copy only half of u, but since
      // it's overlapped and a small amount of data, it's pretty much free and simpler
      // to just copy the whole thing
      //

      dstart = (unsigned int)   STR->u & ~0xF;
      dend   = (((unsigned int) STR->dmaCacheLinePadPostUS) + 0x0F) & ~0x0F;

      irq = DI();

      *D9_SADR = (int) uSPR;
      *D9_MADR = dstart;
      *D9_QWC = (dend - dstart + 15) >> 4;
      *D9_CHCR = D_CHCR_STR_M;

      asm("sync.l");

      if (irq) EI();

      // flag that DMA completion must be checked for below
      check_SPR_completion = TRUE;
      }
#endif

#ifdef MSS_SPU_PROCESS
   S32 incoming = STR->write_cursor - STR->data_size;
#else
   //
   // Read in audio data associated with frame
   //

   S32 incoming = fetch_audio_data(STR);

   if (incoming == -1)
      {
#ifdef IS_PS2
      if (check_SPR_completion)
         {
         while (*D9_CHCR & D_CHCR_STR_M)
            {
            }
         }
#endif

      return 0;
      }
#endif

   //
   // Set read cursor to offset of data for current frame (which is always
   // on a byte boundary, but may be *before* the data just read)
   //

   STR->apos = 8 * (incoming - STR->main_data_begin);

   //
   // If read cursor falls before the start of buffered frame data, we
   // do not have enough data to process this frame -- skip it
   //

   if (STR->apos < 0)
      {
#ifdef IS_PS2
      if (check_SPR_completion)
         {
         while (*D9_CHCR & D_CHCR_STR_M)
            {
            }
         }
#endif
      return 2;
      }

   //
   // For all granules in all channels...
   //

   S32 gr,ch;

   for (gr=0; gr < STR->ngr; gr++)
      {
      //
      // Fetch data and requantize it
      //

      xr_type xr[2];
      xr_type lr[2];

#ifdef IS_PS2
      xr_type *lrptr = use_scratchpad ? (xr_type *) lrSPR : lr;
#else
      xr_type *lrptr = lr;
#endif

      for (ch = 0 ; ch < STR->nch ; ch++)
         {
         is_type is[2];

#ifdef IS_PS2
         is_type *isptr = use_scratchpad ? (is_type *) SPR_IS_START : is;
#else
         is_type *isptr = is;
#endif

         L3_parse     ( STR, gr, ch, isptr );
         L3_requantize( STR, gr, ch, isptr, xr );
         }

      //
      // Perform stereo processing and reordering
      //

      L3_stereo( STR, gr, xr, lrptr );

      //
      // Calculate # of IMDCT operations required to reach zero part of
      // spectrum
      //

      S32 n_dct;

      if ((STR->window_switching_flag[gr][0] && (STR->block_type[gr][0] == 2))
           ||
          (STR->window_switching_flag[gr][1] && (STR->block_type[gr][1] == 2)))
         {
         //
         // Short or mixed blocks use all 32 subbands
         //

         n_dct = SBLIMIT;
         }
      else
         {
         //
         // Pure long blocks can be truncated at zero part
         //

         S32 n0 = ((STR->zero_part[0] - 1) / 18) + 1;
         S32 n1 = ((STR->zero_part[1] - 1) / 18) + 1;

         n_dct = max(n0,n1);
         }

      //
      // Convert to amplitude domain via IMDCT and polyphase filter
      //

      for (ch=0; ch < STR->nch; ch++)
         {
         //
         // Perform alias-reduction
         //

         L3_antialias(STR, gr, ch, lrptr);

         //
         // Synthesize via IMDCT and overlap-add
         //

         S32 win_type;

         if ((STR->window_switching_flag[gr][ch])      &&
             (STR->block_type           [gr][ch] == 2) &&
             (STR->mixed_block_flag     [gr][ch]))
            {
            win_type = 0;
            }
         else if (!STR->window_switching_flag[gr][ch])
            {
            win_type = 0;
            }
         else
            {
            win_type = STR->block_type[gr][ch];
            }

         //
         // Always do first two subbands, then select long windows if
         // appropriate and continue with remaining subbands up to
         // zero part of spectrum
         //

         xr_type res;

         u_type  *uptr   = STR->u;
         xr_type *sptr   = STR->s;
         xr_type &resptr = res;

#ifdef IS_PS2
         //
         // Make sure STR->u and STR->s have finished copying to scratchpad before using them
         //

         if (use_scratchpad)
            {
            if (check_SPR_completion)
               {
               check_SPR_completion = FALSE;

               while (*D9_CHCR & D_CHCR_STR_M)
                  {
                  }
               }

            resptr = *(xr_type *) resSPR;
            sptr   =  (xr_type *) sSPR;
            uptr   =  (u_type *)  uSPR;
            }
#endif

         S32 sb;

         if (win_type == 2)
            {
#if FORCE_SCALAR_MATH
           for (sb=0; sb < 2; sb++)
               {
               Scalar_IMDCT_3x12(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb]);
               }
#elif defined(IS_X86)
#if !defined(IS_XBOX) && !defined(SSE_ONLY)
            if (use_AMD)
               {
               for (sb=0; sb < 2; sb++)
                  {
                  AMD_IMDCT_3x12(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb]);
                  }
               }
            else
#endif
               {
               for (sb=0; sb < 2; sb++)
                  {
                  x86_IMDCT_3x12(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb]);
                  }
               }
#else
#ifdef IS_PS2
           for (sb=0; sb < 2; sb++)
               {
               PS2_IMDCT_3x12(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb]);
               }
#else
           for (sb=0; sb < 2; sb++)
               {
               PPC_IMDCT_3x12(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb]);
               }
#endif
#endif
         }
         else
            {
#if FORCE_SCALAR_MATH
           for (sb=0; sb < 2; sb++)
              {
                 Scalar_IMDCT_1x36(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb], (F32*)(void*)win[win_type]);
              }
#elif defined(IS_X86)
#if !defined(IS_XBOX) && !defined(SSE_ONLY)
            if (use_AMD)
               {
               for (sb=0; sb < 2; sb++)
                  {
                  AMD_IMDCT_1x36(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb], (F32*)(void*)win[win_type]);
                  }
               }
            else
#endif
               {
               for (sb=0; sb < 2; sb++)
                  {
                  x86_IMDCT_1x36(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb], (F32*)(void*)win[win_type]);
                  }
               }
#else
#ifdef IS_PS2
           for (sb=0; sb < 2; sb++)
              {
                 PS2_IMDCT_1x36(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb], (F32*)(void*)win[win_type]);
              }
#else
           for (sb=0; sb < 2; sb++)
              {
                 PPC_IMDCT_1x36(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb], (F32*)(void*)win[win_type]);
              }
#endif
#endif
         }

         if ((STR->window_switching_flag[gr][ch])      &&
             (STR->block_type           [gr][ch] == 2) &&
             (STR->mixed_block_flag     [gr][ch]))
            {
            win_type = 2;
            }

         if (win_type == 2)
            {
#if FORCE_SCALAR_MATH
           for (sb=2; sb < n_dct; sb++)
              {
                 Scalar_IMDCT_3x12(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb]);
              }
#elif defined(IS_X86)
#if !defined(IS_XBOX) && !defined(SSE_ONLY)
            if (use_AMD)
               {
               for (sb=2; sb < n_dct; sb++)
                  {
                  AMD_IMDCT_3x12(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb]);
                  }
               }
            else
#endif
               {
               for (sb=2; sb < n_dct; sb++)
                  {
                  x86_IMDCT_3x12(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb]);
                  }
               }
#else
#ifdef IS_PS2
           for (sb=2; sb < n_dct; sb++)
              {
                 PS2_IMDCT_3x12(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb]);
              }
#else
           for (sb=2; sb < n_dct; sb++)
              {
                 PPC_IMDCT_3x12(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb]);
              }
#endif
#endif
         }
         else
            {
#if FORCE_SCALAR_MATH
           for (sb=2; sb < n_dct; sb++)
              {
                 Scalar_IMDCT_1x36(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb], (F32*)(void*)win[win_type]);
              }
#elif defined(IS_X86)
#if !defined(IS_XBOX) && !defined(SSE_ONLY)
            if (use_AMD)
               {
               for (sb=2; sb < n_dct; sb++)
                  {
                  AMD_IMDCT_1x36(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb], (F32*)(void*)win[win_type]);
                  }
               }
            else
#endif
               {
               for (sb=2; sb < n_dct; sb++)
                  {
                  x86_IMDCT_1x36(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb], (F32*)(void*)win[win_type]);
                  }
               }
#else
#ifdef IS_PS2
           for (sb=2; sb < n_dct; sb++)
              {
                 PS2_IMDCT_1x36(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb], (F32*)(void*)win[win_type]);
              }
#else
           for (sb=2; sb < n_dct; sb++)
              {
                 PPC_IMDCT_1x36(lrptr[ch][sb], sb, resptr[sb], sptr[ch][sb], (F32*)(void*)win[win_type]);
              }
#endif
#endif
         }

         //
         // Clear zero part explicitly, without performing IMDCTs for
         // subbands known to be empty
         //

         while (sb < SBLIMIT)
            {
            AIL_memcpy(resptr[sb],
                       sptr[ch][sb],
                       18 * sizeof(F32));

            AIL_memset(sptr[ch][sb],
                       0,
                       18 * sizeof(F32));
            sb++;
            }

         //
         // Execute final synthesis pass with polyphase filterbank
         //

         for (S32 f=0; f < 18; f++)
            {
            S32 start = STR->u_start[ch];
            S32 div   = STR->u_div  [ch];

#if FORCE_SCALAR_MATH
               Scalar_poly_filter(&resptr[0][0],
                                b,
                                f,
                               &uptr[ch][div][0][start],
                               &uptr[ch][!div][0][start]);

#elif defined(IS_X86)
#if !defined(IS_XBOX) && !defined(SSE_ONLY)
            if (use_AMD)
               {
               AMD_poly_filter(&resptr[0][0],
                                b,
                                f,
                               &uptr[ch][div][0][start],
                               &uptr[ch][!div][0][start]);
               }
            else
#endif
               {
               x86_poly_filter(&resptr[0][0],
                                b,
                                f,
                               &uptr[ch][div][0][start],
                               &uptr[ch][!div][0][start]);
               }
#else
#ifdef IS_PS2
               PS2_poly_filter(&resptr[0][0],
                                b,
                                f,
                               &uptr[ch][div][0][start],
                               &uptr[ch][!div][0][start]);
#else
               PPC_poly_filter(&resptr[0][0],
                                b,
                                f,
                               &uptr[ch][div][0][start],
                               &uptr[ch][!div][0][start]);
#endif
#endif

            //
            // Calculate index into 576-long * 2-channel sample buffer segment
            //

            STR->samples = (S16 *) AIL_ptr_add(&STR->frame_buffer[STR->frame_size],
                                       (64 * sizeof(S16) * (f >> (2 - STR->nch))) +
                                       (2 * sizeof(S16) * ((STR->nch == 2) ? 0 : ((f & 1) ? 16 : 0))) +
                                       (sizeof(S16) * ch));

            //
            // Apply inverse window and emit output samples
            //
#if VECTOR_DEWINDOW
               Vector_dewindow_and_write(uptr[ch][div][0],
                                      (float*)t_dewindow[0],
                                      start,
                                      STR->samples,
                                      STR->nch * sizeof(S16),
                                      div);

#elif FORCE_SCALAR_MATH
               Scalar_dewindow_and_write(uptr[ch][div][0],
                                      (float*)t_dewindow[0],
                                      start,
                                      STR->samples,
                                      STR->nch * sizeof(S16),
                                      div);
#elif defined(IS_X86)

#if !defined(IS_XBOX) && !defined(SSE_ONLY)

            // use SSE in preference to AMD for this function, the only
            // one that currently uses SSE
            if (use_SSE)
#endif
               {
               SSE_dewindow_and_write(uptr[ch][div][0],
                                      t_dewindow[0],
                                      start,
                                      STR->samples,
                                      STR->nch * sizeof(S16),
                                      div);
               }

#if !defined(IS_XBOX) && !defined(SSE_ONLY)

            else
               {
               if (use_AMD)
                  {
                  AMD_dewindow_and_write(uptr[ch][div][0],
                                         t_dewindow[0],
                                         start,
                                         STR->samples,
                                         STR->nch * sizeof(S16),
                                         div);
                  }
               else
                  {
                  x86_dewindow_and_write(uptr[ch][div][0],
                                         t_dewindow[0],
                                         start,
                                         STR->samples,
                                         STR->nch * sizeof(S16),
                                         div);
                  }
               }
#endif

#else
#ifdef IS_PS2
               PS2_dewindow_and_write(uptr[ch][div][0],
                                    t_dewindow[0],
                                    start,
                                    STR->samples,
                                    STR->nch * sizeof(S16),
                                    div);
#else
               PPC_dewindow_and_write(uptr[ch][div][0],
                                      (float*)t_dewindow[0],
                                      start,
                                      STR->samples,
                                      STR->nch * sizeof(S16),
                                      div);
#endif
#endif

            STR->u_start[ch] = (STR->u_start[ch] - 1) & 0x0f;
            STR->u_div  [ch] = !STR->u_div[ch];
            }

         }

      //
      // Advance frame buffer pointer
      //

      STR->frame_size += (32 * 18 * STR->nch * sizeof(S16));
      }

#ifdef IS_PS2


      if (use_scratchpad)
         {
         //
         // Copy STR->u and STR->s back from scratchpad
         //
         // We already checked to make sure there was no active DMA from the scratchpad at the top of the routine
         //

         dstart = (unsigned int) STR->u & ~0xF;
         dend = (((unsigned int) STR->dmaCacheLinePadPostUS) + 0x0F) & ~0x0F;

         irq = DI();

         *D8_MADR = dstart;
         *D8_SADR = (int) uSPR;
         *D8_QWC = (dend - dstart + 15) >> 4;
         *D8_CHCR = D_CHCR_STR_M;

         asm("sync.l");

         if (irq) EI();

         //
         // We don't need to wait for this transfer to finish, because everyone else who uses the SPR
         // is responsible for blocking on in-progress DMA...
         //
         }

#endif

   //
   // Return success
   //

   return 1;
}

